/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * The Blue Alliance API v3
 * # Overview    Information and statistics about FIRST Robotics Competition teams and events.   # Authentication   All endpoints require an Auth Key to be passed in the header `X-TBA-Auth-Key`. If you do not have an auth key yet, you can obtain one from your [Account Page](/account).
 *
 * OpenAPI spec version: 3.8.2
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://www.thebluealliance.com/api/v3".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface APIStatus
 */
export interface APIStatus {
    /**
     * Year of the current FRC season.
     * @type {number}
     * @memberof APIStatus
     */
    currentSeason: number;
    /**
     * Maximum FRC season year for valid queries.
     * @type {number}
     * @memberof APIStatus
     */
    maxSeason: number;
    /**
     * True if the entire FMS API provided by FIRST is down.
     * @type {boolean}
     * @memberof APIStatus
     */
    isDatafeedDown: boolean;
    /**
     * An array of strings containing event keys of any active events that are no longer updating.
     * @type {Array<string>}
     * @memberof APIStatus
     */
    downEvents: Array<string>;
    /**
     * 
     * @type {APIStatusAppVersion}
     * @memberof APIStatus
     */
    ios: APIStatusAppVersion;
    /**
     * 
     * @type {APIStatusAppVersion}
     * @memberof APIStatus
     */
    android: APIStatusAppVersion;
}
/**
 * 
 * @export
 * @interface APIStatusAppVersion
 */
export interface APIStatusAppVersion {
    /**
     * Internal use - Minimum application version required to correctly connect and process data.
     * @type {number}
     * @memberof APIStatusAppVersion
     */
    minAppVersion: number;
    /**
     * Internal use - Latest application version available.
     * @type {number}
     * @memberof APIStatusAppVersion
     */
    latestAppVersion: number;
}
/**
 * 
 * @export
 * @interface Award
 */
export interface Award {
    /**
     * The name of the award as provided by FIRST. May vary for the same award type.
     * @type {string}
     * @memberof Award
     */
    name: string;
    /**
     * Type of award given. See https://github.com/the-blue-alliance/the-blue-alliance/blob/master/consts/award_type.py#L6
     * @type {number}
     * @memberof Award
     */
    awardType: number;
    /**
     * The event_key of the event the award was won at.
     * @type {string}
     * @memberof Award
     */
    eventKey: string;
    /**
     * A list of recipients of the award at the event. May have either a team_key or an awardee, both, or neither (in the case the award wasn't awarded at the event).
     * @type {Array<AwardRecipient>}
     * @memberof Award
     */
    recipientList: Array<AwardRecipient>;
    /**
     * The year this award was won.
     * @type {number}
     * @memberof Award
     */
    year: number;
}
/**
 * An `Award_Recipient` object represents the team and/or person who received an award at an event.
 * @export
 * @interface AwardRecipient
 */
export interface AwardRecipient {
    /**
     * The TBA team key for the team that was given the award. May be null.
     * @type {string}
     * @memberof AwardRecipient
     */
    teamKey?: string;
    /**
     * The name of the individual given the award. May be null.
     * @type {string}
     * @memberof AwardRecipient
     */
    awardee?: string;
}
/**
 * 
 * @export
 * @interface DistrictList
 */
export interface DistrictList {
    /**
     * The short identifier for the district.
     * @type {string}
     * @memberof DistrictList
     */
    abbreviation: string;
    /**
     * The long name for the district.
     * @type {string}
     * @memberof DistrictList
     */
    displayName: string;
    /**
     * Key for this district, e.g. `2016ne`.
     * @type {string}
     * @memberof DistrictList
     */
    key: string;
    /**
     * Year this district participated.
     * @type {number}
     * @memberof DistrictList
     */
    year: number;
}
/**
 * Rank of a team in a district.
 * @export
 * @interface DistrictRanking
 */
export interface DistrictRanking {
    /**
     * TBA team key for the team.
     * @type {string}
     * @memberof DistrictRanking
     */
    teamKey: string;
    /**
     * Numerical rank of the team, 1 being top rank.
     * @type {number}
     * @memberof DistrictRanking
     */
    rank: number;
    /**
     * Any points added to a team as a result of the rookie bonus.
     * @type {number}
     * @memberof DistrictRanking
     */
    rookieBonus?: number;
    /**
     * Total district points for the team.
     * @type {number}
     * @memberof DistrictRanking
     */
    pointTotal: number;
    /**
     * List of events that contributed to the point total for the team.
     * @type {Array<DistrictRankingEventPoints>}
     * @memberof DistrictRanking
     */
    eventPoints?: Array<DistrictRankingEventPoints>;
}
/**
 * 
 * @export
 * @interface DistrictRankingEventPoints
 */
export interface DistrictRankingEventPoints {
    /**
     * `true` if this event is a District Championship event.
     * @type {boolean}
     * @memberof DistrictRankingEventPoints
     */
    districtCmp: boolean;
    /**
     * Total points awarded at this event.
     * @type {number}
     * @memberof DistrictRankingEventPoints
     */
    total: number;
    /**
     * Points awarded for alliance selection.
     * @type {number}
     * @memberof DistrictRankingEventPoints
     */
    alliancePoints: number;
    /**
     * Points awarded for elimination match performance.
     * @type {number}
     * @memberof DistrictRankingEventPoints
     */
    elimPoints: number;
    /**
     * Points awarded for event awards.
     * @type {number}
     * @memberof DistrictRankingEventPoints
     */
    awardPoints: number;
    /**
     * TBA Event key for this event.
     * @type {string}
     * @memberof DistrictRankingEventPoints
     */
    eventKey: string;
    /**
     * Points awarded for qualification match performance.
     * @type {number}
     * @memberof DistrictRankingEventPoints
     */
    qualPoints: number;
}
/**
 * 
 * @export
 * @interface EliminationAlliance
 */
export interface EliminationAlliance {
    /**
     * Alliance name, may be null.
     * @type {string}
     * @memberof EliminationAlliance
     */
    name?: string;
    /**
     * 
     * @type {EliminationAllianceBackup}
     * @memberof EliminationAlliance
     */
    backup?: EliminationAllianceBackup;
    /**
     * List of teams that declined the alliance.
     * @type {Array<string>}
     * @memberof EliminationAlliance
     */
    declines?: Array<string>;
    /**
     * List of team keys picked for the alliance. First pick is captain.
     * @type {Array<string>}
     * @memberof EliminationAlliance
     */
    picks: Array<string>;
    /**
     * 
     * @type {EliminationAllianceStatus}
     * @memberof EliminationAlliance
     */
    status?: EliminationAllianceStatus;
}
/**
 * Backup team called in, may be null.
 * @export
 * @interface EliminationAllianceBackup
 */
export interface EliminationAllianceBackup {
    /**
     * Team key that was called in as the backup.
     * @type {string}
     * @memberof EliminationAllianceBackup
     */
    _in?: string;
    /**
     * Team key that was replaced by the backup team.
     * @type {string}
     * @memberof EliminationAllianceBackup
     */
    out?: string;
}
/**
 * 
 * @export
 * @interface EliminationAllianceStatus
 */
export interface EliminationAllianceStatus {
    /**
     * 
     * @type {number}
     * @memberof EliminationAllianceStatus
     */
    playoffAverage?: number;
    /**
     * 
     * @type {string}
     * @memberof EliminationAllianceStatus
     */
    level?: string;
    /**
     * 
     * @type {WLTRecord}
     * @memberof EliminationAllianceStatus
     */
    record?: WLTRecord;
    /**
     * 
     * @type {WLTRecord}
     * @memberof EliminationAllianceStatus
     */
    currentLevelRecord?: WLTRecord;
    /**
     * 
     * @type {string}
     * @memberof EliminationAllianceStatus
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * TBA event key with the format yyyy[EVENT_CODE], where yyyy is the year, and EVENT_CODE is the event code of the event.
     * @type {string}
     * @memberof Event
     */
    key: string;
    /**
     * Official name of event on record either provided by FIRST or organizers of offseason event.
     * @type {string}
     * @memberof Event
     */
    name: string;
    /**
     * Event short code, as provided by FIRST.
     * @type {string}
     * @memberof Event
     */
    eventCode: string;
    /**
     * Event Type, as defined here: https://github.com/the-blue-alliance/the-blue-alliance/blob/master/consts/event_type.py#L2
     * @type {number}
     * @memberof Event
     */
    eventType: number;
    /**
     * 
     * @type {DistrictList}
     * @memberof Event
     */
    district?: DistrictList;
    /**
     * City, town, village, etc. the event is located in.
     * @type {string}
     * @memberof Event
     */
    city?: string;
    /**
     * State or Province the event is located in.
     * @type {string}
     * @memberof Event
     */
    stateProv?: string;
    /**
     * Country the event is located in.
     * @type {string}
     * @memberof Event
     */
    country?: string;
    /**
     * Event start date in `yyyy-mm-dd` format.
     * @type {string}
     * @memberof Event
     */
    startDate: string;
    /**
     * Event end date in `yyyy-mm-dd` format.
     * @type {string}
     * @memberof Event
     */
    endDate: string;
    /**
     * Year the event data is for.
     * @type {number}
     * @memberof Event
     */
    year: number;
    /**
     * Same as `name` but doesn't include event specifiers, such as 'Regional' or 'District'. May be null.
     * @type {string}
     * @memberof Event
     */
    shortName?: string;
    /**
     * Event Type, eg Regional, District, or Offseason.
     * @type {string}
     * @memberof Event
     */
    eventTypeString: string;
    /**
     * Week of the event relative to the first official season event, zero-indexed. Only valid for Regionals, Districts, and District Championships. Null otherwise. (Eg. A season with a week 0 'preseason' event does not count, and week 1 events will show 0 here. Seasons with a week 0.5 regional event will show week 0 for those event(s) and week 1 for week 1 events and so on.)
     * @type {number}
     * @memberof Event
     */
    week?: number;
    /**
     * Address of the event's venue, if available.
     * @type {string}
     * @memberof Event
     */
    address?: string;
    /**
     * Postal code from the event address.
     * @type {string}
     * @memberof Event
     */
    postalCode?: string;
    /**
     * Google Maps Place ID for the event address.
     * @type {string}
     * @memberof Event
     */
    gmapsPlaceId?: string;
    /**
     * Link to address location on Google Maps.
     * @type {string}
     * @memberof Event
     */
    gmapsUrl?: string;
    /**
     * Latitude for the event address.
     * @type {number}
     * @memberof Event
     */
    lat?: number;
    /**
     * Longitude for the event address.
     * @type {number}
     * @memberof Event
     */
    lng?: number;
    /**
     * Name of the location at the address for the event, eg. Blue Alliance High School.
     * @type {string}
     * @memberof Event
     */
    locationName?: string;
    /**
     * Timezone name.
     * @type {string}
     * @memberof Event
     */
    timezone?: string;
    /**
     * The event's website, if any.
     * @type {string}
     * @memberof Event
     */
    website?: string;
    /**
     * The FIRST internal Event ID, used to link to the event on the FRC webpage.
     * @type {string}
     * @memberof Event
     */
    firstEventId?: string;
    /**
     * Public facing event code used by FIRST (on frc-events.firstinspires.org, for example)
     * @type {string}
     * @memberof Event
     */
    firstEventCode?: string;
    /**
     * 
     * @type {Array<Webcast>}
     * @memberof Event
     */
    webcasts?: Array<Webcast>;
    /**
     * An array of event keys for the divisions at this event.
     * @type {Array<string>}
     * @memberof Event
     */
    divisionKeys?: Array<string>;
    /**
     * The TBA Event key that represents the event's parent. Used to link back to the event from a division event. It is also the inverse relation of `divison_keys`.
     * @type {string}
     * @memberof Event
     */
    parentEventKey?: string;
    /**
     * Playoff Type, as defined here: https://github.com/the-blue-alliance/the-blue-alliance/blob/master/consts/playoff_type.py#L4, or null.
     * @type {number}
     * @memberof Event
     */
    playoffType?: number;
    /**
     * String representation of the `playoff_type`, or null.
     * @type {string}
     * @memberof Event
     */
    playoffTypeString?: string;
}
/**
 * 
 * @export
 * @interface EventDistrictPoints
 */
export interface EventDistrictPoints {
    /**
     * Points gained for each team at the event. Stored as a key-value pair with the team key as the key, and an object describing the points as its value.
     * @type {{ [key: string]: EventDistrictPointsPoints; }}
     * @memberof EventDistrictPoints
     */
    points: { [key: string]: EventDistrictPointsPoints; };
    /**
     * Tiebreaker values for each team at the event. Stored as a key-value pair with the team key as the key, and an object describing the tiebreaker elements as its value.
     * @type {{ [key: string]: EventDistrictPointsTiebreakers; }}
     * @memberof EventDistrictPoints
     */
    tiebreakers?: { [key: string]: EventDistrictPointsTiebreakers; };
}
/**
 * 
 * @export
 * @interface EventDistrictPointsPoints
 */
export interface EventDistrictPointsPoints {
    /**
     * Total points awarded at this event.
     * @type {number}
     * @memberof EventDistrictPointsPoints
     */
    total: number;
    /**
     * Points awarded for alliance selection
     * @type {number}
     * @memberof EventDistrictPointsPoints
     */
    alliancePoints: number;
    /**
     * Points awarded for elimination match performance.
     * @type {number}
     * @memberof EventDistrictPointsPoints
     */
    elimPoints: number;
    /**
     * Points awarded for event awards.
     * @type {number}
     * @memberof EventDistrictPointsPoints
     */
    awardPoints: number;
    /**
     * Points awarded for qualification match performance.
     * @type {number}
     * @memberof EventDistrictPointsPoints
     */
    qualPoints: number;
}
/**
 * 
 * @export
 * @interface EventDistrictPointsTiebreakers
 */
export interface EventDistrictPointsTiebreakers {
    /**
     * 
     * @type {Array<number>}
     * @memberof EventDistrictPointsTiebreakers
     */
    highestQualScores?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof EventDistrictPointsTiebreakers
     */
    qualWins?: number;
}
/**
 * A year-specific event insight object expressed as a JSON string, separated in to `qual` and `playoff` fields. See also Event_Insights_2016, Event_Insights_2017, etc.
 * @export
 * @interface EventInsights
 */
export interface EventInsights {
    /**
     * Inights for the qualification round of an event
     * @type {any}
     * @memberof EventInsights
     */
    qual?: any;
    /**
     * Insights for the playoff round of an event
     * @type {any}
     * @memberof EventInsights
     */
    playoff?: any;
}
/**
 * Insights for FIRST Stronghold qualification and elimination matches.
 * @export
 * @interface EventInsights2016
 */
export interface EventInsights2016 {
    /**
     * For the Low Bar - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    lowBar: Array<number>;
    /**
     * For the Cheval De Frise - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    aChevalDeFrise: Array<number>;
    /**
     * For the Portcullis - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    aPortcullis: Array<number>;
    /**
     * For the Ramparts - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    bRamparts: Array<number>;
    /**
     * For the Moat - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    bMoat: Array<number>;
    /**
     * For the Sally Port - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    cSallyPort: Array<number>;
    /**
     * For the Drawbridge - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    cDrawbridge: Array<number>;
    /**
     * For the Rough Terrain - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    dRoughTerrain: Array<number>;
    /**
     * For the Rock Wall - An array with three values, number of times damaged, number of opportunities to damage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    dRockWall: Array<number>;
    /**
     * Average number of high goals scored.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageHighGoals: number;
    /**
     * Average number of low goals scored.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageLowGoals: number;
    /**
     * An array with three values, number of times breached, number of opportunities to breach, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    breaches: Array<number>;
    /**
     * An array with three values, number of times scaled, number of opportunities to scale, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    scales: Array<number>;
    /**
     * An array with three values, number of times challenged, number of opportunities to challenge, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    challenges: Array<number>;
    /**
     * An array with three values, number of times captured, number of opportunities to capture, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2016
     */
    captures: Array<number>;
    /**
     * Average winning score.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageWinScore: number;
    /**
     * Average margin of victory.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageWinMargin: number;
    /**
     * Average total score.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageScore: number;
    /**
     * Average autonomous score.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageAutoScore: number;
    /**
     * Average crossing score.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageCrossingScore: number;
    /**
     * Average boulder score.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageBoulderScore: number;
    /**
     * Average tower score.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageTowerScore: number;
    /**
     * Average foul score.
     * @type {number}
     * @memberof EventInsights2016
     */
    averageFoulScore: number;
    /**
     * An array with three values, high score, match key from the match with the high score, and the name of the match.
     * @type {Array<string>}
     * @memberof EventInsights2016
     */
    highScore: Array<string>;
}
/**
 * Insights for FIRST STEAMWORKS qualification and elimination matches.
 * @export
 * @interface EventInsights2017
 */
export interface EventInsights2017 {
    /**
     * Average foul score.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageFoulScore: number;
    /**
     * Average fuel points scored.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageFuelPoints: number;
    /**
     * Average fuel points scored during auto.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageFuelPointsAuto: number;
    /**
     * Average fuel points scored during teleop.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageFuelPointsTeleop: number;
    /**
     * Average points scored in the high goal.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageHighGoals: number;
    /**
     * Average points scored in the high goal during auto.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageHighGoalsAuto: number;
    /**
     * Average points scored in the high goal during teleop.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageHighGoalsTeleop: number;
    /**
     * Average points scored in the low goal.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageLowGoals: number;
    /**
     * Average points scored in the low goal during auto.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageLowGoalsAuto: number;
    /**
     * Average points scored in the low goal during teleop.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageLowGoalsTeleop: number;
    /**
     * Average mobility points scored during auto.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageMobilityPointsAuto: number;
    /**
     * Average points scored during auto.
     * @type {number}
     * @memberof EventInsights2017
     */
    averagePointsAuto: number;
    /**
     * Average points scored during teleop.
     * @type {number}
     * @memberof EventInsights2017
     */
    averagePointsTeleop: number;
    /**
     * Average rotor points scored.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageRotorPoints: number;
    /**
     * Average rotor points scored during auto.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageRotorPointsAuto: number;
    /**
     * Average rotor points scored during teleop.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageRotorPointsTeleop: number;
    /**
     * Average score.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageScore: number;
    /**
     * Average takeoff points scored during teleop.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageTakeoffPointsTeleop: number;
    /**
     * Average margin of victory.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageWinMargin: number;
    /**
     * Average winning score.
     * @type {number}
     * @memberof EventInsights2017
     */
    averageWinScore: number;
    /**
     * An array with three values, kPa scored, match key from the match with the high kPa, and the name of the match
     * @type {Array<string>}
     * @memberof EventInsights2017
     */
    highKpa: Array<string>;
    /**
     * An array with three values, high score, match key from the match with the high score, and the name of the match
     * @type {Array<string>}
     * @memberof EventInsights2017
     */
    highScore: Array<string>;
    /**
     * An array with three values, number of times kPa bonus achieved, number of opportunities to bonus, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    kpaAchieved: Array<number>;
    /**
     * An array with three values, number of times mobility bonus achieved, number of opportunities to bonus, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    mobilityCounts: Array<number>;
    /**
     * An array with three values, number of times rotor 1 engaged, number of opportunities to engage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    rotor1Engaged: Array<number>;
    /**
     * An array with three values, number of times rotor 1 engaged in auto, number of opportunities to engage in auto, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    rotor1EngagedAuto: Array<number>;
    /**
     * An array with three values, number of times rotor 2 engaged, number of opportunities to engage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    rotor2Engaged: Array<number>;
    /**
     * An array with three values, number of times rotor 2 engaged in auto, number of opportunities to engage in auto, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    rotor2EngagedAuto: Array<number>;
    /**
     * An array with three values, number of times rotor 3 engaged, number of opportunities to engage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    rotor3Engaged: Array<number>;
    /**
     * An array with three values, number of times rotor 4 engaged, number of opportunities to engage, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    rotor4Engaged: Array<number>;
    /**
     * An array with three values, number of times takeoff was counted, number of opportunities to takeoff, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    takeoffCounts: Array<number>;
    /**
     * An array with three values, number of times a unicorn match (Win + kPa & Rotor Bonuses) occured, number of opportunities to have a unicorn match, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2017
     */
    unicornMatches: Array<number>;
}
/**
 * Insights for FIRST Power Up qualification and elimination matches.
 * @export
 * @interface EventInsights2018
 */
export interface EventInsights2018 {
    /**
     * An array with three values, number of times auto quest was completed, number of opportunities to complete the auto quest, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    autoQuestAchieved: Array<number>;
    /**
     * Average number of boost power up scored (out of 3).
     * @type {number}
     * @memberof EventInsights2018
     */
    averageBoostPlayed: number;
    /**
     * Average endgame points.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageEndgamePoints: number;
    /**
     * Average number of force power up scored (out of 3).
     * @type {number}
     * @memberof EventInsights2018
     */
    averageForcePlayed: number;
    /**
     * Average foul score.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageFoulScore: number;
    /**
     * Average points scored during auto.
     * @type {number}
     * @memberof EventInsights2018
     */
    averagePointsAuto: number;
    /**
     * Average points scored during teleop.
     * @type {number}
     * @memberof EventInsights2018
     */
    averagePointsTeleop: number;
    /**
     * Average mobility points scored during auto.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageRunPointsAuto: number;
    /**
     * Average scale ownership points scored.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageScaleOwnershipPoints: number;
    /**
     * Average scale ownership points scored during auto.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageScaleOwnershipPointsAuto: number;
    /**
     * Average scale ownership points scored during teleop.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageScaleOwnershipPointsTeleop: number;
    /**
     * Average score.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageScore: number;
    /**
     * Average switch ownership points scored.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageSwitchOwnershipPoints: number;
    /**
     * Average switch ownership points scored during auto.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageSwitchOwnershipPointsAuto: number;
    /**
     * Average switch ownership points scored during teleop.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageSwitchOwnershipPointsTeleop: number;
    /**
     * Average value points scored.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageVaultPoints: number;
    /**
     * Average margin of victory.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageWinMargin: number;
    /**
     * Average winning score.
     * @type {number}
     * @memberof EventInsights2018
     */
    averageWinScore: number;
    /**
     * An array with three values, number of times a boost power up was played, number of opportunities to play a boost power up, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    boostPlayedCounts: Array<number>;
    /**
     * An array with three values, number of times a climb occurred, number of opportunities to climb, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    climbCounts: Array<number>;
    /**
     * An array with three values, number of times an alliance faced the boss, number of opportunities to face the boss, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    faceTheBossAchieved: Array<number>;
    /**
     * An array with three values, number of times a force power up was played, number of opportunities to play a force power up, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    forcePlayedCounts: Array<number>;
    /**
     * An array with three values, high score, match key from the match with the high score, and the name of the match
     * @type {Array<string>}
     * @memberof EventInsights2018
     */
    highScore: Array<string>;
    /**
     * An array with three values, number of times a levitate power up was played, number of opportunities to play a levitate power up, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    levitatePlayedCounts: Array<number>;
    /**
     * An array with three values, number of times a team scored mobility points in auto, number of opportunities to score mobility points in auto, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    runCountsAuto: Array<number>;
    /**
     * Average scale neutral percentage.
     * @type {number}
     * @memberof EventInsights2018
     */
    scaleNeutralPercentage: number;
    /**
     * Average scale neutral percentage during auto.
     * @type {number}
     * @memberof EventInsights2018
     */
    scaleNeutralPercentageAuto: number;
    /**
     * Average scale neutral percentage during teleop.
     * @type {number}
     * @memberof EventInsights2018
     */
    scaleNeutralPercentageTeleop: number;
    /**
     * An array with three values, number of times a switch was owned during auto, number of opportunities to own a switch during auto, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    switchOwnedCountsAuto: Array<number>;
    /**
     * An array with three values, number of times a unicorn match (Win + Auto Quest + Face the Boss) occurred, number of opportunities to have a unicorn match, and percentage.
     * @type {Array<number>}
     * @memberof EventInsights2018
     */
    unicornMatches: Array<number>;
    /**
     * Average opposing switch denail percentage for the winning alliance during teleop.
     * @type {number}
     * @memberof EventInsights2018
     */
    winningOppSwitchDenialPercentageTeleop: number;
    /**
     * Average own switch ownership percentage for the winning alliance.
     * @type {number}
     * @memberof EventInsights2018
     */
    winningOwnSwitchOwnershipPercentage: number;
    /**
     * Average own switch ownership percentage for the winning alliance during auto.
     * @type {number}
     * @memberof EventInsights2018
     */
    winningOwnSwitchOwnershipPercentageAuto: number;
    /**
     * Average own switch ownership percentage for the winning alliance during teleop.
     * @type {number}
     * @memberof EventInsights2018
     */
    winningOwnSwitchOwnershipPercentageTeleop: number;
    /**
     * Average scale ownership percentage for the winning alliance.
     * @type {number}
     * @memberof EventInsights2018
     */
    winningScaleOwnershipPercentage: number;
    /**
     * Average scale ownership percentage for the winning alliance during auto.
     * @type {number}
     * @memberof EventInsights2018
     */
    winningScaleOwnershipPercentageAuto: number;
    /**
     * Average scale ownership percentage for the winning alliance during teleop.
     * @type {number}
     * @memberof EventInsights2018
     */
    winningScaleOwnershipPercentageTeleop: number;
}
/**
 * OPR, DPR, and CCWM for teams at the event.
 * @export
 * @interface EventOPRs
 */
export interface EventOPRs {
    /**
     * A key-value pair with team key (eg `frc254`) as key and OPR as value.
     * @type {{ [key: string]: number; }}
     * @memberof EventOPRs
     */
    oprs?: { [key: string]: number; };
    /**
     * A key-value pair with team key (eg `frc254`) as key and DPR as value.
     * @type {{ [key: string]: number; }}
     * @memberof EventOPRs
     */
    dprs?: { [key: string]: number; };
    /**
     * A key-value pair with team key (eg `frc254`) as key and CCWM as value.
     * @type {{ [key: string]: number; }}
     * @memberof EventOPRs
     */
    ccwms?: { [key: string]: number; };
}
/**
 * JSON Object containing prediction information for the event. Contains year-specific information and is subject to change.
 * @export
 * @interface EventPredictions
 */
export interface EventPredictions {
}
/**
 * 
 * @export
 * @interface EventRanking
 */
export interface EventRanking {
    /**
     * List of rankings at the event.
     * @type {Array<EventRankingRankings>}
     * @memberof EventRanking
     */
    rankings: Array<EventRankingRankings>;
    /**
     * List of special TBA-generated values provided in the `extra_stats` array for each item.
     * @type {Array<EventRankingExtraStatsInfo>}
     * @memberof EventRanking
     */
    extraStatsInfo?: Array<EventRankingExtraStatsInfo>;
    /**
     * List of year-specific values provided in the `sort_orders` array for each team.
     * @type {Array<EventRankingSortOrderInfo>}
     * @memberof EventRanking
     */
    sortOrderInfo: Array<EventRankingSortOrderInfo>;
}
/**
 * 
 * @export
 * @interface EventRankingExtraStatsInfo
 */
export interface EventRankingExtraStatsInfo {
    /**
     * Integer expressing the number of digits of precision in the number provided in `sort_orders`.
     * @type {number}
     * @memberof EventRankingExtraStatsInfo
     */
    precision: number;
    /**
     * Name of the field used in the `extra_stats` array.
     * @type {string}
     * @memberof EventRankingExtraStatsInfo
     */
    name: string;
}
/**
 * 
 * @export
 * @interface EventRankingRankings
 */
export interface EventRankingRankings {
    /**
     * Number of matches played by this team.
     * @type {number}
     * @memberof EventRankingRankings
     */
    matchesPlayed: number;
    /**
     * The average match score during qualifications. Year specific. May be null if not relevant for a given year.
     * @type {number}
     * @memberof EventRankingRankings
     */
    qualAverage?: number;
    /**
     * Additional special data on the team's performance calculated by TBA.
     * @type {Array<number>}
     * @memberof EventRankingRankings
     */
    extraStats?: Array<number>;
    /**
     * Additional year-specific information, may be null. See parent `sort_order_info` for details.
     * @type {Array<number>}
     * @memberof EventRankingRankings
     */
    sortOrders?: Array<number>;
    /**
     * 
     * @type {WLTRecord}
     * @memberof EventRankingRankings
     */
    record: WLTRecord;
    /**
     * The team's rank at the event as provided by FIRST.
     * @type {number}
     * @memberof EventRankingRankings
     */
    rank: number;
    /**
     * Number of times disqualified.
     * @type {number}
     * @memberof EventRankingRankings
     */
    dq: number;
    /**
     * The team with this rank.
     * @type {string}
     * @memberof EventRankingRankings
     */
    teamKey: string;
}
/**
 * 
 * @export
 * @interface EventRankingSortOrderInfo
 */
export interface EventRankingSortOrderInfo {
    /**
     * Integer expressing the number of digits of precision in the number provided in `sort_orders`.
     * @type {number}
     * @memberof EventRankingSortOrderInfo
     */
    precision: number;
    /**
     * Name of the field used in the `sort_order` array.
     * @type {string}
     * @memberof EventRankingSortOrderInfo
     */
    name: string;
}
/**
 * 
 * @export
 * @interface EventSimple
 */
export interface EventSimple {
    /**
     * TBA event key with the format yyyy[EVENT_CODE], where yyyy is the year, and EVENT_CODE is the event code of the event.
     * @type {string}
     * @memberof EventSimple
     */
    key: string;
    /**
     * Official name of event on record either provided by FIRST or organizers of offseason event.
     * @type {string}
     * @memberof EventSimple
     */
    name: string;
    /**
     * Event short code, as provided by FIRST.
     * @type {string}
     * @memberof EventSimple
     */
    eventCode: string;
    /**
     * Event Type, as defined here: https://github.com/the-blue-alliance/the-blue-alliance/blob/master/consts/event_type.py#L2
     * @type {number}
     * @memberof EventSimple
     */
    eventType: number;
    /**
     * 
     * @type {DistrictList}
     * @memberof EventSimple
     */
    district?: DistrictList;
    /**
     * City, town, village, etc. the event is located in.
     * @type {string}
     * @memberof EventSimple
     */
    city?: string;
    /**
     * State or Province the event is located in.
     * @type {string}
     * @memberof EventSimple
     */
    stateProv?: string;
    /**
     * Country the event is located in.
     * @type {string}
     * @memberof EventSimple
     */
    country?: string;
    /**
     * Event start date in `yyyy-mm-dd` format.
     * @type {string}
     * @memberof EventSimple
     */
    startDate: string;
    /**
     * Event end date in `yyyy-mm-dd` format.
     * @type {string}
     * @memberof EventSimple
     */
    endDate: string;
    /**
     * Year the event data is for.
     * @type {number}
     * @memberof EventSimple
     */
    year: number;
}
/**
 * 
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * TBA match key with the format `yyyy[EVENT_CODE]_[COMP_LEVEL]m[MATCH_NUMBER]`, where `yyyy` is the year, and `EVENT_CODE` is the event code of the event, `COMP_LEVEL` is (qm, ef, qf, sf, f), and `MATCH_NUMBER` is the match number in the competition level. A set number may be appended to the competition level if more than one match in required per set.
     * @type {string}
     * @memberof Match
     */
    key: string;
    /**
     * The competition level the match was played at.
     * @type {string}
     * @memberof Match
     */
    compLevel: Match.CompLevelEnum;
    /**
     * The set number in a series of matches where more than one match is required in the match series.
     * @type {number}
     * @memberof Match
     */
    setNumber: number;
    /**
     * The match number of the match in the competition level.
     * @type {number}
     * @memberof Match
     */
    matchNumber: number;
    /**
     * 
     * @type {MatchSimpleAlliances}
     * @memberof Match
     */
    alliances?: MatchSimpleAlliances;
    /**
     * The color (red/blue) of the winning alliance. Will contain an empty string in the event of no winner, or a tie.
     * @type {string}
     * @memberof Match
     */
    winningAlliance?: Match.WinningAllianceEnum;
    /**
     * Event key of the event the match was played at.
     * @type {string}
     * @memberof Match
     */
    eventKey: string;
    /**
     * UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of the scheduled match time, as taken from the published schedule.
     * @type {number}
     * @memberof Match
     */
    time?: number;
    /**
     * UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of actual match start time.
     * @type {number}
     * @memberof Match
     */
    actualTime?: number;
    /**
     * UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of the TBA predicted match start time.
     * @type {number}
     * @memberof Match
     */
    predictedTime?: number;
    /**
     * UNIX timestamp (seconds since 1-Jan-1970 00:00:00) when the match result was posted.
     * @type {number}
     * @memberof Match
     */
    postResultTime?: number;
    /**
     * Score breakdown for auto, teleop, etc. points. Varies from year to year. May be null.
     * @type {any}
     * @memberof Match
     */
    scoreBreakdown?: any;
    /**
     * Array of video objects associated with this match.
     * @type {Array<MatchVideos>}
     * @memberof Match
     */
    videos?: Array<MatchVideos>;
}

/**
 * @export
 * @namespace Match
 */
export namespace Match {
    /**
     * @export
     * @enum {string}
     */
    export enum CompLevelEnum {
        Qm = <any> 'qm',
        Ef = <any> 'ef',
        Qf = <any> 'qf',
        Sf = <any> 'sf',
        F = <any> 'f'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WinningAllianceEnum {
        Red = <any> 'red',
        Blue = <any> 'blue',
        Empty = <any> ''
    }
}
/**
 * 
 * @export
 * @interface MatchAlliance
 */
export interface MatchAlliance {
    /**
     * Score for this alliance. Will be null or -1 for an unplayed match.
     * @type {number}
     * @memberof MatchAlliance
     */
    score: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchAlliance
     */
    teamKeys: Array<string>;
    /**
     * TBA team keys (eg `frc254`) of any teams playing as a surrogate.
     * @type {Array<string>}
     * @memberof MatchAlliance
     */
    surrogateTeamKeys?: Array<string>;
    /**
     * TBA team keys (eg `frc254`) of any disqualified teams.
     * @type {Array<string>}
     * @memberof MatchAlliance
     */
    dqTeamKeys?: Array<string>;
}
/**
 * See the 2015 FMS API documentation for a description of each value
 * @export
 * @interface MatchScoreBreakdown2015
 */
export interface MatchScoreBreakdown2015 {
    /**
     * 
     * @type {MatchScoreBreakdown2015Alliance}
     * @memberof MatchScoreBreakdown2015
     */
    blue?: MatchScoreBreakdown2015Alliance;
    /**
     * 
     * @type {MatchScoreBreakdown2015Alliance}
     * @memberof MatchScoreBreakdown2015
     */
    red?: MatchScoreBreakdown2015Alliance;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2015
     */
    coopertition?: MatchScoreBreakdown2015.CoopertitionEnum;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015
     */
    coopertitionPoints?: number;
}

/**
 * @export
 * @namespace MatchScoreBreakdown2015
 */
export namespace MatchScoreBreakdown2015 {
    /**
     * @export
     * @enum {string}
     */
    export enum CoopertitionEnum {
        None = <any> 'None',
        Unknown = <any> 'Unknown',
        Stack = <any> 'Stack'
    }
}
/**
 * 
 * @export
 * @interface MatchScoreBreakdown2015Alliance
 */
export interface MatchScoreBreakdown2015Alliance {
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    autoPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    teleopPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    containerPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    totePoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    litterPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    foulPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    adjustPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    totalPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    foulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    toteCountFar?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    toteCountNear?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    toteSet?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    toteStack?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    containerCountLevel1?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    containerCountLevel2?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    containerCountLevel3?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    containerCountLevel4?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    containerCountLevel5?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    containerCountLevel6?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    containerSet?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    litterCountContainer?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    litterCountLandfill?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    litterCountUnprocessed?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2015Alliance
     */
    robotSet?: boolean;
}
/**
 * See the 2016 FMS API documentation for a description of each value.
 * @export
 * @interface MatchScoreBreakdown2016
 */
export interface MatchScoreBreakdown2016 {
    /**
     * 
     * @type {MatchScoreBreakdown2016Alliance}
     * @memberof MatchScoreBreakdown2016
     */
    blue?: MatchScoreBreakdown2016Alliance;
    /**
     * 
     * @type {MatchScoreBreakdown2016Alliance}
     * @memberof MatchScoreBreakdown2016
     */
    red?: MatchScoreBreakdown2016Alliance;
}
/**
 * 
 * @export
 * @interface MatchScoreBreakdown2016Alliance
 */
export interface MatchScoreBreakdown2016Alliance {
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    autoPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    breachPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    foulPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    capturePoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    adjustPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    totalPoints?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    robot1Auto?: MatchScoreBreakdown2016Alliance.Robot1AutoEnum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    robot2Auto?: MatchScoreBreakdown2016Alliance.Robot2AutoEnum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    robot3Auto?: MatchScoreBreakdown2016Alliance.Robot3AutoEnum;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    autoReachPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    autoCrossingPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    autoBouldersLow?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    autoBouldersHigh?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    autoBoulderPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopCrossingPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopBouldersLow?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopBouldersHigh?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopBoulderPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopDefensesBreached?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopChallengePoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopScalePoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    teleopTowerCaptured?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    towerFaceA?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    towerFaceB?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    towerFaceC?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    towerEndStrength?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    techFoulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    foulCount?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position3?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position4?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position5?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position1crossings?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position2crossings?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position3crossings?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position4crossings?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2016Alliance
     */
    position5crossings?: number;
}

/**
 * @export
 * @namespace MatchScoreBreakdown2016Alliance
 */
export namespace MatchScoreBreakdown2016Alliance {
    /**
     * @export
     * @enum {string}
     */
    export enum Robot1AutoEnum {
        Crossed = <any> 'Crossed',
        Reached = <any> 'Reached',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum Robot2AutoEnum {
        Crossed = <any> 'Crossed',
        Reached = <any> 'Reached',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum Robot3AutoEnum {
        Crossed = <any> 'Crossed',
        Reached = <any> 'Reached',
        None = <any> 'None'
    }
}
/**
 * See the 2017 FMS API documentation for a description of each value.
 * @export
 * @interface MatchScoreBreakdown2017
 */
export interface MatchScoreBreakdown2017 {
    /**
     * 
     * @type {MatchScoreBreakdown2017Alliance}
     * @memberof MatchScoreBreakdown2017
     */
    blue?: MatchScoreBreakdown2017Alliance;
    /**
     * 
     * @type {MatchScoreBreakdown2017Alliance}
     * @memberof MatchScoreBreakdown2017
     */
    red?: MatchScoreBreakdown2017Alliance;
}
/**
 * 
 * @export
 * @interface MatchScoreBreakdown2017Alliance
 */
export interface MatchScoreBreakdown2017Alliance {
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    autoPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    teleopPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    foulPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    adjustPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    totalPoints?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    robot1Auto?: MatchScoreBreakdown2017Alliance.Robot1AutoEnum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    robot2Auto?: MatchScoreBreakdown2017Alliance.Robot2AutoEnum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    robot3Auto?: MatchScoreBreakdown2017Alliance.Robot3AutoEnum;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    rotor1Auto?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    rotor2Auto?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    autoFuelLow?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    autoFuelHigh?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    autoMobilityPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    autoRotorPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    autoFuelPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    teleopFuelPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    teleopFuelLow?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    teleopFuelHigh?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    teleopRotorPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    kPaRankingPointAchieved?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    teleopTakeoffPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    kPaBonusPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    rotorBonusPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    rotor1Engaged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    rotor2Engaged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    rotor3Engaged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    rotor4Engaged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    rotorRankingPointAchieved?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    techFoulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    foulCount?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    touchpadNear?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    touchpadMiddle?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2017Alliance
     */
    touchpadFar?: string;
}

/**
 * @export
 * @namespace MatchScoreBreakdown2017Alliance
 */
export namespace MatchScoreBreakdown2017Alliance {
    /**
     * @export
     * @enum {string}
     */
    export enum Robot1AutoEnum {
        Unknown = <any> 'Unknown',
        Mobility = <any> 'Mobility',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum Robot2AutoEnum {
        Unknown = <any> 'Unknown',
        Mobility = <any> 'Mobility',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum Robot3AutoEnum {
        Unknown = <any> 'Unknown',
        Mobility = <any> 'Mobility',
        None = <any> 'None'
    }
}
/**
 * See the 2018 FMS API documentation for a description of each value. https://frcevents2.docs.apiary.io/#/reference/match-results/score-details
 * @export
 * @interface MatchScoreBreakdown2018
 */
export interface MatchScoreBreakdown2018 {
    /**
     * 
     * @type {MatchScoreBreakdown2018Alliance}
     * @memberof MatchScoreBreakdown2018
     */
    blue?: MatchScoreBreakdown2018Alliance;
    /**
     * 
     * @type {MatchScoreBreakdown2018Alliance}
     * @memberof MatchScoreBreakdown2018
     */
    red?: MatchScoreBreakdown2018Alliance;
}
/**
 * 
 * @export
 * @interface MatchScoreBreakdown2018Alliance
 */
export interface MatchScoreBreakdown2018Alliance {
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    adjustPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoOwnershipPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoQuestRankingPoint?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoRobot1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoRobot2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoRobot3?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoRunPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoScaleOwnershipSec?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoSwitchAtZero?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    autoSwitchOwnershipSec?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    endgamePoints?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    endgameRobot1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    endgameRobot2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    endgameRobot3?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    faceTheBossRankingPoint?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    foulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    foulPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    rp?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    techFoulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    teleopOwnershipPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    teleopPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    teleopScaleBoostSec?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    teleopScaleForceSec?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    teleopScaleOwnershipSec?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    teleopSwitchBoostSec?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    teleopSwitchForceSec?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    teleopSwitchOwnershipSec?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    totalPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    vaultBoostPlayed?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    vaultBoostTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    vaultForcePlayed?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    vaultForceTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    vaultLevitatePlayed?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    vaultLevitateTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    vaultPoints?: number;
    /**
     * Unofficial TBA-computed value of the FMS provided GameData given to the alliance teams at the start of the match. 3 Character String containing `L` and `R` only. The first character represents the near switch, the 2nd the scale, and the 3rd the far, opposing, switch from the alliance's perspective. An `L` in a position indicates the platform on the left will be lit for the alliance while an `R` will indicate the right platform will be lit for the alliance. See also [WPI Screen Steps](https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/826278-2018-game-data-details).
     * @type {string}
     * @memberof MatchScoreBreakdown2018Alliance
     */
    tbaGameData?: string;
}
/**
 * See the 2019 FMS API documentation for a description of each value. https://frcevents2.docs.apiary.io/#/reference/match-results/score-details
 * @export
 * @interface MatchScoreBreakdown2019
 */
export interface MatchScoreBreakdown2019 {
    /**
     * 
     * @type {MatchScoreBreakdown2019Alliance}
     * @memberof MatchScoreBreakdown2019
     */
    blue?: MatchScoreBreakdown2019Alliance;
    /**
     * 
     * @type {MatchScoreBreakdown2019Alliance}
     * @memberof MatchScoreBreakdown2019
     */
    red?: MatchScoreBreakdown2019Alliance;
}
/**
 * 
 * @export
 * @interface MatchScoreBreakdown2019Alliance
 */
export interface MatchScoreBreakdown2019Alliance {
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    adjustPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    autoPoints?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    bay1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    bay2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    bay3?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    bay4?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    bay5?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    bay6?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    bay7?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    bay8?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    cargoPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    completeRocketRankingPoint?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    completedRocketFar?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    completedRocketNear?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    endgameRobot1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    endgameRobot2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    endgameRobot3?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    foulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    foulPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    habClimbPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    habDockingRankingPoint?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    habLineRobot1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    habLineRobot2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    habLineRobot3?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    hatchPanelPoints?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    lowLeftRocketFar?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    lowLeftRocketNear?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    lowRightRocketFar?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    lowRightRocketNear?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    midLeftRocketFar?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    midLeftRocketNear?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    midRightRocketFar?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    midRightRocketNear?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchBay1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchBay2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchBay3?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchBay6?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchBay7?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchBay8?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchLevelRobot1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchLevelRobot2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    preMatchLevelRobot3?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    rp?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    sandStormBonusPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    techFoulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    teleopPoints?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    topLeftRocketFar?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    topLeftRocketNear?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    topRightRocketFar?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    topRightRocketNear?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2019Alliance
     */
    totalPoints?: number;
}
/**
 * See the 2020 FMS API documentation for a description of each value. https://frcevents2.docs.apiary.io/#/reference/match-results/score-details
 * @export
 * @interface MatchScoreBreakdown2020
 */
export interface MatchScoreBreakdown2020 {
    /**
     * 
     * @type {MatchScoreBreakdown2020Alliance}
     * @memberof MatchScoreBreakdown2020
     */
    blue?: MatchScoreBreakdown2020Alliance;
    /**
     * 
     * @type {MatchScoreBreakdown2020Alliance}
     * @memberof MatchScoreBreakdown2020
     */
    red?: MatchScoreBreakdown2020Alliance;
}
/**
 * 
 * @export
 * @interface MatchScoreBreakdown2020Alliance
 */
export interface MatchScoreBreakdown2020Alliance {
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    initLineRobot1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    endgameRobot1?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    initLineRobot2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    endgameRobot2?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    initLineRobot3?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    endgameRobot3?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    autoCellsBottom?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    autoCellsOuter?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    autoCellsInner?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    teleopCellsBottom?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    teleopCellsOuter?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    teleopCellsInner?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    stage1Activated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    stage2Activated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    stage3Activated?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    stage3TargetColor?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    endgameRungIsLevel?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    autoInitLinePoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    autoCellPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    autoPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    teleopCellPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    controlPanelPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    endgamePoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    teleopPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    shieldOperationalRankingPoint?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    shieldEnergizedRankingPoint?: boolean;
    /**
     * Unofficial TBA-computed value that indicates whether the shieldEnergizedRankingPoint was earned normally or awarded due to a foul.
     * @type {boolean}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    tbaShieldEnergizedRankingPointFromFoul?: boolean;
    /**
     * Unofficial TBA-computed value that counts the number of robots who were hanging at the end of the match.
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    tbaNumRobotsHanging?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    foulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    techFoulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    adjustPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    foulPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    rp?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2020Alliance
     */
    totalPoints?: number;
}
/**
 * See the 2022 FMS API documentation for a description of each value. https://frc-api-docs.firstinspires.org
 * @export
 * @interface MatchScoreBreakdown2022
 */
export interface MatchScoreBreakdown2022 {
    /**
     * 
     * @type {MatchScoreBreakdown2022Alliance}
     * @memberof MatchScoreBreakdown2022
     */
    blue?: MatchScoreBreakdown2022Alliance;
    /**
     * 
     * @type {MatchScoreBreakdown2022Alliance}
     * @memberof MatchScoreBreakdown2022
     */
    red?: MatchScoreBreakdown2022Alliance;
}
/**
 * 
 * @export
 * @interface MatchScoreBreakdown2022Alliance
 */
export interface MatchScoreBreakdown2022Alliance {
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    taxiRobot1?: MatchScoreBreakdown2022Alliance.TaxiRobot1Enum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    endgameRobot1?: MatchScoreBreakdown2022Alliance.EndgameRobot1Enum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    taxiRobot2?: MatchScoreBreakdown2022Alliance.TaxiRobot2Enum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    endgameRobot2?: MatchScoreBreakdown2022Alliance.EndgameRobot2Enum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    taxiRobot3?: MatchScoreBreakdown2022Alliance.TaxiRobot3Enum;
    /**
     * 
     * @type {string}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    endgameRobot3?: MatchScoreBreakdown2022Alliance.EndgameRobot3Enum;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoLowerNear?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoLowerFar?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoLowerBlue?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoLowerRed?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoUpperNear?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoUpperFar?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoUpperBlue?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoUpperRed?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoLowerNear?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoLowerFar?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoLowerBlue?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoLowerRed?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoUpperNear?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoUpperFar?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoUpperBlue?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoUpperRed?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    matchCargoTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoTaxiPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoCargoPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    autoPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    quintetAchieved?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopCargoPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    endgamePoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    teleopPoints?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    cargoBonusRankingPoint?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    hangarBonusRankingPoint?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    foulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    techFoulCount?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    adjustPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    foulPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    rp?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchScoreBreakdown2022Alliance
     */
    totalPoints?: number;
}

/**
 * @export
 * @namespace MatchScoreBreakdown2022Alliance
 */
export namespace MatchScoreBreakdown2022Alliance {
    /**
     * @export
     * @enum {string}
     */
    export enum TaxiRobot1Enum {
        Yes = <any> 'Yes',
        No = <any> 'No'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EndgameRobot1Enum {
        Traversal = <any> 'Traversal',
        High = <any> 'High',
        Mid = <any> 'Mid',
        Low = <any> 'Low',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TaxiRobot2Enum {
        Yes = <any> 'Yes',
        No = <any> 'No'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EndgameRobot2Enum {
        Traversal = <any> 'Traversal',
        High = <any> 'High',
        Mid = <any> 'Mid',
        Low = <any> 'Low',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TaxiRobot3Enum {
        Yes = <any> 'Yes',
        No = <any> 'No'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EndgameRobot3Enum {
        Traversal = <any> 'Traversal',
        High = <any> 'High',
        Mid = <any> 'Mid',
        Low = <any> 'Low',
        None = <any> 'None'
    }
}
/**
 * 
 * @export
 * @interface MatchSimple
 */
export interface MatchSimple {
    /**
     * TBA match key with the format `yyyy[EVENT_CODE]_[COMP_LEVEL]m[MATCH_NUMBER]`, where `yyyy` is the year, and `EVENT_CODE` is the event code of the event, `COMP_LEVEL` is (qm, ef, qf, sf, f), and `MATCH_NUMBER` is the match number in the competition level. A set number may append the competition level if more than one match in required per set.
     * @type {string}
     * @memberof MatchSimple
     */
    key: string;
    /**
     * The competition level the match was played at.
     * @type {string}
     * @memberof MatchSimple
     */
    compLevel: MatchSimple.CompLevelEnum;
    /**
     * The set number in a series of matches where more than one match is required in the match series.
     * @type {number}
     * @memberof MatchSimple
     */
    setNumber: number;
    /**
     * The match number of the match in the competition level.
     * @type {number}
     * @memberof MatchSimple
     */
    matchNumber: number;
    /**
     * 
     * @type {MatchSimpleAlliances}
     * @memberof MatchSimple
     */
    alliances?: MatchSimpleAlliances;
    /**
     * The color (red/blue) of the winning alliance. Will contain an empty string in the event of no winner, or a tie.
     * @type {string}
     * @memberof MatchSimple
     */
    winningAlliance?: MatchSimple.WinningAllianceEnum;
    /**
     * Event key of the event the match was played at.
     * @type {string}
     * @memberof MatchSimple
     */
    eventKey: string;
    /**
     * UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of the scheduled match time, as taken from the published schedule.
     * @type {number}
     * @memberof MatchSimple
     */
    time?: number;
    /**
     * UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of the TBA predicted match start time.
     * @type {number}
     * @memberof MatchSimple
     */
    predictedTime?: number;
    /**
     * UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of actual match start time.
     * @type {number}
     * @memberof MatchSimple
     */
    actualTime?: number;
}

/**
 * @export
 * @namespace MatchSimple
 */
export namespace MatchSimple {
    /**
     * @export
     * @enum {string}
     */
    export enum CompLevelEnum {
        Qm = <any> 'qm',
        Ef = <any> 'ef',
        Qf = <any> 'qf',
        Sf = <any> 'sf',
        F = <any> 'f'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WinningAllianceEnum {
        Red = <any> 'red',
        Blue = <any> 'blue',
        Empty = <any> ''
    }
}
/**
 * A list of alliances, the teams on the alliances, and their score.
 * @export
 * @interface MatchSimpleAlliances
 */
export interface MatchSimpleAlliances {
    /**
     * 
     * @type {MatchAlliance}
     * @memberof MatchSimpleAlliances
     */
    red?: MatchAlliance;
    /**
     * 
     * @type {MatchAlliance}
     * @memberof MatchSimpleAlliances
     */
    blue?: MatchAlliance;
}
/**
 * Timeseries data for the 2018 game *FIRST* POWER UP. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This model is currently under active development and may change at any time, including in breaking ways.
 * @export
 * @interface MatchTimeseries2018
 */
export interface MatchTimeseries2018 {
    /**
     * TBA event key with the format yyyy[EVENT_CODE], where yyyy is the year, and EVENT_CODE is the event code of the event.
     * @type {string}
     * @memberof MatchTimeseries2018
     */
    eventKey?: string;
    /**
     * Match ID consisting of the level, match number, and set number, eg `qm45` or `f1m1`.
     * @type {string}
     * @memberof MatchTimeseries2018
     */
    matchId?: string;
    /**
     * Current mode of play, can be `pre_match`, `auto`, `telop`, or `post_match`.
     * @type {string}
     * @memberof MatchTimeseries2018
     */
    mode?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    play?: number;
    /**
     * Amount of time remaining in the match, only valid during `auto` and `teleop` modes.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    timeRemaining?: number;
    /**
     * 1 if the blue alliance is credited with the AUTO QUEST, 0 if not.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueAutoQuest?: number;
    /**
     * Number of POWER CUBES in the BOOST section of the blue alliance VAULT.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueBoostCount?: number;
    /**
     * Returns 1 if the blue alliance BOOST was played, or 0 if not played.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueBoostPlayed?: number;
    /**
     * Name of the current blue alliance POWER UP being played, or `null`.
     * @type {string}
     * @memberof MatchTimeseries2018
     */
    blueCurrentPowerup?: string;
    /**
     * 1 if the blue alliance is credited with FACING THE BOSS, 0 if not.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueFaceTheBoss?: number;
    /**
     * Number of POWER CUBES in the FORCE section of the blue alliance VAULT.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueForceCount?: number;
    /**
     * Returns 1 if the blue alliance FORCE was played, or 0 if not played.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueForcePlayed?: number;
    /**
     * Number of POWER CUBES in the LEVITATE section of the blue alliance VAULT.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueLevitateCount?: number;
    /**
     * Returns 1 if the blue alliance LEVITATE was played, or 0 if not played.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueLevitatePlayed?: number;
    /**
     * Number of seconds remaining in the blue alliance POWER UP time, or 0 if none is active.
     * @type {string}
     * @memberof MatchTimeseries2018
     */
    bluePowerupTimeRemaining?: string;
    /**
     * 1 if the blue alliance owns the SCALE, 0 if not.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueScaleOwned?: number;
    /**
     * Current score for the blue alliance.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueScore?: number;
    /**
     * 1 if the blue alliance owns their SWITCH, 0 if not.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    blueSwitchOwned?: number;
    /**
     * 1 if the red alliance is credited with the AUTO QUEST, 0 if not.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redAutoQuest?: number;
    /**
     * Number of POWER CUBES in the BOOST section of the red alliance VAULT.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redBoostCount?: number;
    /**
     * Returns 1 if the red alliance BOOST was played, or 0 if not played.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redBoostPlayed?: number;
    /**
     * Name of the current red alliance POWER UP being played, or `null`.
     * @type {string}
     * @memberof MatchTimeseries2018
     */
    redCurrentPowerup?: string;
    /**
     * 1 if the red alliance is credited with FACING THE BOSS, 0 if not.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redFaceTheBoss?: number;
    /**
     * Number of POWER CUBES in the FORCE section of the red alliance VAULT.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redForceCount?: number;
    /**
     * Returns 1 if the red alliance FORCE was played, or 0 if not played.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redForcePlayed?: number;
    /**
     * Number of POWER CUBES in the LEVITATE section of the red alliance VAULT.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redLevitateCount?: number;
    /**
     * Returns 1 if the red alliance LEVITATE was played, or 0 if not played.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redLevitatePlayed?: number;
    /**
     * Number of seconds remaining in the red alliance POWER UP time, or 0 if none is active.
     * @type {string}
     * @memberof MatchTimeseries2018
     */
    redPowerupTimeRemaining?: string;
    /**
     * 1 if the red alliance owns the SCALE, 0 if not.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redScaleOwned?: number;
    /**
     * Current score for the red alliance.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redScore?: number;
    /**
     * 1 if the red alliance owns their SWITCH, 0 if not.
     * @type {number}
     * @memberof MatchTimeseries2018
     */
    redSwitchOwned?: number;
}
/**
 * 
 * @export
 * @interface MatchVideos
 */
export interface MatchVideos {
    /**
     * Can be one of 'youtube' or 'tba'
     * @type {string}
     * @memberof MatchVideos
     */
    type?: string;
    /**
     * Unique key representing this video
     * @type {string}
     * @memberof MatchVideos
     */
    key?: string;
}
/**
 * The `Media` object contains a reference for most any media associated with a team or event on TBA.
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * String type of the media element.
     * @type {string}
     * @memberof Media
     */
    type: Media.TypeEnum;
    /**
     * The key used to identify this media on the media site.
     * @type {string}
     * @memberof Media
     */
    foreignKey: string;
    /**
     * If required, a JSON dict of additional media information.
     * @type {any}
     * @memberof Media
     */
    details?: any;
    /**
     * True if the media is of high quality.
     * @type {boolean}
     * @memberof Media
     */
    preferred?: boolean;
    /**
     * Direct URL to the media.
     * @type {string}
     * @memberof Media
     */
    directUrl?: string;
    /**
     * The URL that leads to the full web page for the media, if one exists.
     * @type {string}
     * @memberof Media
     */
    viewUrl?: string;
}

/**
 * @export
 * @namespace Media
 */
export namespace Media {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Youtube = <any> 'youtube',
        Cdphotothread = <any> 'cdphotothread',
        Imgur = <any> 'imgur',
        FacebookProfile = <any> 'facebook-profile',
        YoutubeChannel = <any> 'youtube-channel',
        TwitterProfile = <any> 'twitter-profile',
        GithubProfile = <any> 'github-profile',
        InstagramProfile = <any> 'instagram-profile',
        PeriscopeProfile = <any> 'periscope-profile',
        Grabcad = <any> 'grabcad',
        InstagramImage = <any> 'instagram-image',
        ExternalLink = <any> 'external-link',
        Avatar = <any> 'avatar'
    }
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * TBA team key with the format `frcXXXX` with `XXXX` representing the team number.
     * @type {string}
     * @memberof Team
     */
    key: string;
    /**
     * Official team number issued by FIRST.
     * @type {number}
     * @memberof Team
     */
    teamNumber: number;
    /**
     * Team nickname provided by FIRST.
     * @type {string}
     * @memberof Team
     */
    nickname?: string;
    /**
     * Official long name registered with FIRST.
     * @type {string}
     * @memberof Team
     */
    name: string;
    /**
     * Name of team school or affilited group registered with FIRST.
     * @type {string}
     * @memberof Team
     */
    schoolName?: string;
    /**
     * City of team derived from parsing the address registered with FIRST.
     * @type {string}
     * @memberof Team
     */
    city?: string;
    /**
     * State of team derived from parsing the address registered with FIRST.
     * @type {string}
     * @memberof Team
     */
    stateProv?: string;
    /**
     * Country of team derived from parsing the address registered with FIRST.
     * @type {string}
     * @memberof Team
     */
    country?: string;
    /**
     * Will be NULL, for future development.
     * @type {string}
     * @memberof Team
     */
    address?: string;
    /**
     * Postal code from the team address.
     * @type {string}
     * @memberof Team
     */
    postalCode?: string;
    /**
     * Will be NULL, for future development.
     * @type {string}
     * @memberof Team
     */
    gmapsPlaceId?: string;
    /**
     * Will be NULL, for future development.
     * @type {string}
     * @memberof Team
     */
    gmapsUrl?: string;
    /**
     * Will be NULL, for future development.
     * @type {number}
     * @memberof Team
     */
    lat?: number;
    /**
     * Will be NULL, for future development.
     * @type {number}
     * @memberof Team
     */
    lng?: number;
    /**
     * Will be NULL, for future development.
     * @type {string}
     * @memberof Team
     */
    locationName?: string;
    /**
     * Official website associated with the team.
     * @type {string}
     * @memberof Team
     */
    website?: string;
    /**
     * First year the team officially competed.
     * @type {number}
     * @memberof Team
     */
    rookieYear?: number;
    /**
     * Team's motto as provided by FIRST. This field is deprecated and will return null - will be removed at end-of-season in 2019.
     * @type {string}
     * @memberof Team
     */
    motto?: string;
    /**
     * Location of the team's home championship each year as a key-value pair. The year (as a string) is the key, and the city is the value.
     * @type {any}
     * @memberof Team
     */
    homeChampionship?: any;
}
/**
 * 
 * @export
 * @interface TeamEventStatus
 */
export interface TeamEventStatus {
    /**
     * 
     * @type {TeamEventStatusRank}
     * @memberof TeamEventStatus
     */
    qual?: TeamEventStatusRank;
    /**
     * 
     * @type {TeamEventStatusAlliance}
     * @memberof TeamEventStatus
     */
    alliance?: TeamEventStatusAlliance;
    /**
     * 
     * @type {TeamEventStatusPlayoff}
     * @memberof TeamEventStatus
     */
    playoff?: TeamEventStatusPlayoff;
    /**
     * An HTML formatted string suitable for display to the user containing the team's alliance pick status.
     * @type {string}
     * @memberof TeamEventStatus
     */
    allianceStatusStr?: string;
    /**
     * An HTML formatter string suitable for display to the user containing the team's playoff status.
     * @type {string}
     * @memberof TeamEventStatus
     */
    playoffStatusStr?: string;
    /**
     * An HTML formatted string suitable for display to the user containing the team's overall status summary of the event.
     * @type {string}
     * @memberof TeamEventStatus
     */
    overallStatusStr?: string;
    /**
     * TBA match key for the next match the team is scheduled to play in at this event, or null.
     * @type {string}
     * @memberof TeamEventStatus
     */
    nextMatchKey?: string;
    /**
     * TBA match key for the last match the team played in at this event, or null.
     * @type {string}
     * @memberof TeamEventStatus
     */
    lastMatchKey?: string;
}
/**
 * 
 * @export
 * @interface TeamEventStatusAlliance
 */
export interface TeamEventStatusAlliance {
    /**
     * Alliance name, may be null.
     * @type {string}
     * @memberof TeamEventStatusAlliance
     */
    name?: string;
    /**
     * Alliance number.
     * @type {number}
     * @memberof TeamEventStatusAlliance
     */
    number: number;
    /**
     * 
     * @type {TeamEventStatusAllianceBackup}
     * @memberof TeamEventStatusAlliance
     */
    backup?: TeamEventStatusAllianceBackup;
    /**
     * Order the team was picked in the alliance from 0-2, with 0 being alliance captain.
     * @type {number}
     * @memberof TeamEventStatusAlliance
     */
    pick: number;
}
/**
 * Backup status, may be null.
 * @export
 * @interface TeamEventStatusAllianceBackup
 */
export interface TeamEventStatusAllianceBackup {
    /**
     * TBA key for the team replaced by the backup.
     * @type {string}
     * @memberof TeamEventStatusAllianceBackup
     */
    out?: string;
    /**
     * TBA key for the backup team called in.
     * @type {string}
     * @memberof TeamEventStatusAllianceBackup
     */
    _in?: string;
}
/**
 * Playoff status for this team, may be null if the team did not make playoffs, or playoffs have not begun.
 * @export
 * @interface TeamEventStatusPlayoff
 */
export interface TeamEventStatusPlayoff {
    /**
     * The highest playoff level the team reached.
     * @type {string}
     * @memberof TeamEventStatusPlayoff
     */
    level?: TeamEventStatusPlayoff.LevelEnum;
    /**
     * 
     * @type {WLTRecord}
     * @memberof TeamEventStatusPlayoff
     */
    currentLevelRecord?: WLTRecord;
    /**
     * 
     * @type {WLTRecord}
     * @memberof TeamEventStatusPlayoff
     */
    record?: WLTRecord;
    /**
     * Current competition status for the playoffs.
     * @type {string}
     * @memberof TeamEventStatusPlayoff
     */
    status?: TeamEventStatusPlayoff.StatusEnum;
    /**
     * The average match score during playoffs. Year specific. May be null if not relevant for a given year.
     * @type {number}
     * @memberof TeamEventStatusPlayoff
     */
    playoffAverage?: number;
}

/**
 * @export
 * @namespace TeamEventStatusPlayoff
 */
export namespace TeamEventStatusPlayoff {
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Qm = <any> 'qm',
        Ef = <any> 'ef',
        Qf = <any> 'qf',
        Sf = <any> 'sf',
        F = <any> 'f'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Won = <any> 'won',
        Eliminated = <any> 'eliminated',
        Playing = <any> 'playing'
    }
}
/**
 * 
 * @export
 * @interface TeamEventStatusRank
 */
export interface TeamEventStatusRank {
    /**
     * Number of teams ranked.
     * @type {number}
     * @memberof TeamEventStatusRank
     */
    numTeams?: number;
    /**
     * 
     * @type {TeamEventStatusRankRanking}
     * @memberof TeamEventStatusRank
     */
    ranking?: TeamEventStatusRankRanking;
    /**
     * Ordered list of names corresponding to the elements of the `sort_orders` array.
     * @type {Array<TeamEventStatusRankSortOrderInfo>}
     * @memberof TeamEventStatusRank
     */
    sortOrderInfo?: Array<TeamEventStatusRankSortOrderInfo>;
    /**
     * 
     * @type {string}
     * @memberof TeamEventStatusRank
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface TeamEventStatusRankRanking
 */
export interface TeamEventStatusRankRanking {
    /**
     * Number of matches played.
     * @type {number}
     * @memberof TeamEventStatusRankRanking
     */
    matchesPlayed?: number;
    /**
     * For some years, average qualification score. Can be null.
     * @type {number}
     * @memberof TeamEventStatusRankRanking
     */
    qualAverage?: number;
    /**
     * Ordered list of values used to determine the rank. See the `sort_order_info` property for the name of each value.
     * @type {Array<number>}
     * @memberof TeamEventStatusRankRanking
     */
    sortOrders?: Array<number>;
    /**
     * 
     * @type {WLTRecord}
     * @memberof TeamEventStatusRankRanking
     */
    record?: WLTRecord;
    /**
     * Relative rank of this team.
     * @type {number}
     * @memberof TeamEventStatusRankRanking
     */
    rank?: number;
    /**
     * Number of matches the team was disqualified for.
     * @type {number}
     * @memberof TeamEventStatusRankRanking
     */
    dq?: number;
    /**
     * TBA team key for this rank.
     * @type {string}
     * @memberof TeamEventStatusRankRanking
     */
    teamKey?: string;
}
/**
 * 
 * @export
 * @interface TeamEventStatusRankSortOrderInfo
 */
export interface TeamEventStatusRankSortOrderInfo {
    /**
     * The number of digits of precision used for this value, eg `2` would correspond to a value of `101.11` while `0` would correspond to `101`.
     * @type {number}
     * @memberof TeamEventStatusRankSortOrderInfo
     */
    precision?: number;
    /**
     * The descriptive name of the value used to sort the ranking.
     * @type {string}
     * @memberof TeamEventStatusRankSortOrderInfo
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface TeamRobot
 */
export interface TeamRobot {
    /**
     * Year this robot competed in.
     * @type {number}
     * @memberof TeamRobot
     */
    year: number;
    /**
     * Name of the robot as provided by the team.
     * @type {string}
     * @memberof TeamRobot
     */
    robotName: string;
    /**
     * Internal TBA identifier for this robot.
     * @type {string}
     * @memberof TeamRobot
     */
    key: string;
    /**
     * TBA team key for this robot.
     * @type {string}
     * @memberof TeamRobot
     */
    teamKey: string;
}
/**
 * 
 * @export
 * @interface TeamSimple
 */
export interface TeamSimple {
    /**
     * TBA team key with the format `frcXXXX` with `XXXX` representing the team number.
     * @type {string}
     * @memberof TeamSimple
     */
    key: string;
    /**
     * Official team number issued by FIRST.
     * @type {number}
     * @memberof TeamSimple
     */
    teamNumber: number;
    /**
     * Team nickname provided by FIRST.
     * @type {string}
     * @memberof TeamSimple
     */
    nickname?: string;
    /**
     * Official long name registered with FIRST.
     * @type {string}
     * @memberof TeamSimple
     */
    name: string;
    /**
     * City of team derived from parsing the address registered with FIRST.
     * @type {string}
     * @memberof TeamSimple
     */
    city?: string;
    /**
     * State of team derived from parsing the address registered with FIRST.
     * @type {string}
     * @memberof TeamSimple
     */
    stateProv?: string;
    /**
     * Country of team derived from parsing the address registered with FIRST.
     * @type {string}
     * @memberof TeamSimple
     */
    country?: string;
}
/**
 * A Win-Loss-Tie record for a team, or an alliance.
 * @export
 * @interface WLTRecord
 */
export interface WLTRecord {
    /**
     * Number of losses.
     * @type {number}
     * @memberof WLTRecord
     */
    losses: number;
    /**
     * Number of wins.
     * @type {number}
     * @memberof WLTRecord
     */
    wins: number;
    /**
     * Number of ties.
     * @type {number}
     * @memberof WLTRecord
     */
    ties: number;
}
/**
 * 
 * @export
 * @interface Webcast
 */
export interface Webcast {
    /**
     * Type of webcast, typically descriptive of the streaming provider.
     * @type {string}
     * @memberof Webcast
     */
    type: Webcast.TypeEnum;
    /**
     * Type specific channel information. May be the YouTube stream, or Twitch channel name. In the case of iframe types, contains HTML to embed the stream in an HTML iframe.
     * @type {string}
     * @memberof Webcast
     */
    channel: string;
    /**
     * The date for the webcast in `yyyy-mm-dd` format. May be null.
     * @type {string}
     * @memberof Webcast
     */
    date?: string;
    /**
     * File identification as may be required for some types. May be null.
     * @type {string}
     * @memberof Webcast
     */
    file?: string;
}

/**
 * @export
 * @namespace Webcast
 */
export namespace Webcast {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Youtube = <any> 'youtube',
        Twitch = <any> 'twitch',
        Ustream = <any> 'ustream',
        Iframe = <any> 'iframe',
        Html5 = <any> 'html5',
        Rtmp = <any> 'rtmp',
        Livestream = <any> 'livestream',
        DirectLink = <any> 'direct_link',
        Mms = <any> 'mms',
        Justin = <any> 'justin',
        Stemtv = <any> 'stemtv',
        Dacast = <any> 'dacast'
    }
}
/**
 * 
 * @export
 * @interface Zebra
 */
export interface Zebra {
    /**
     * TBA match key with the format `yyyy[EVENT_CODE]_[COMP_LEVEL]m[MATCH_NUMBER]`, where `yyyy` is the year, and `EVENT_CODE` is the event code of the event, `COMP_LEVEL` is (qm, ef, qf, sf, f), and `MATCH_NUMBER` is the match number in the competition level. A set number may be appended to the competition level if more than one match in required per set.
     * @type {string}
     * @memberof Zebra
     */
    key: string;
    /**
     * A list of relative timestamps for each data point. Each timestamp will correspond to the X and Y value at the same index in a team xs and ys arrays. `times`, all teams `xs` and all teams `ys` are guarenteed to be the same length.
     * @type {Array<number>}
     * @memberof Zebra
     */
    times: Array<number>;
    /**
     * 
     * @type {ZebraAlliances}
     * @memberof Zebra
     */
    alliances: ZebraAlliances;
}
/**
 * 
 * @export
 * @interface ZebraAlliances
 */
export interface ZebraAlliances {
    /**
     * Zebra MotionWorks data for teams on the red alliance
     * @type {Array<ZebraTeam>}
     * @memberof ZebraAlliances
     */
    red?: Array<ZebraTeam>;
    /**
     * Zebra data for teams on the blue alliance
     * @type {Array<ZebraTeam>}
     * @memberof ZebraAlliances
     */
    blue?: Array<ZebraTeam>;
}
/**
 * 
 * @export
 * @interface ZebraTeam
 */
export interface ZebraTeam {
    /**
     * The TBA team key for the Zebra MotionWorks data.
     * @type {string}
     * @memberof ZebraTeam
     */
    teamKey: string;
    /**
     * A list containing doubles and nulls representing a teams X position in feet at the corresponding timestamp. A null value represents no tracking data for a given timestamp.
     * @type {Array<number>}
     * @memberof ZebraTeam
     */
    xs: Array<number>;
    /**
     * A list containing doubles and nulls representing a teams Y position in feet at the corresponding timestamp. A null value represents no tracking data for a given timestamp.
     * @type {Array<number>}
     * @memberof ZebraTeam
     */
    ys: Array<number>;
}
/**
 * DistrictApi - fetch parameter creator
 * @export
 */
export const DistrictApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEvents.');
            }
            const localVarPath = `/district/{district_key}/events`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEventsKeys.');
            }
            const localVarPath = `/district/{district_key}/events/keys`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEventsSimple.');
            }
            const localVarPath = `/district/{district_key}/events/simple`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictRankings.');
            }
            const localVarPath = `/district/{district_key}/rankings`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeams.');
            }
            const localVarPath = `/district/{district_key}/teams`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeamsKeys.');
            }
            const localVarPath = `/district/{district_key}/teams/keys`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeamsSimple.');
            }
            const localVarPath = `/district/{district_key}/teams/simple`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of districts and their corresponding district key, for the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictsByYear(year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getDistrictsByYear.');
            }
            const localVarPath = `/districts/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDistrictPoints(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventDistrictPoints.');
            }
            const localVarPath = `/event/{event_key}/district_points`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of districts representing each year the team was in a district. Will return an empty array if the team was never in a district.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDistricts(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamDistricts.');
            }
            const localVarPath = `/team/{team_key}/districts`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistrictApi - functional programming interface
 * @export
 */
export const DistrictApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getDistrictEvents(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DistrictRanking>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getDistrictRankings(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getDistrictTeams(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of districts and their corresponding district key, for the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictsByYear(year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DistrictList>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getDistrictsByYear(year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDistrictPoints(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventDistrictPoints> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getEventDistrictPoints(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets an array of districts representing each year the team was in a district. Will return an empty array if the team was never in a district.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDistricts(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DistrictList>> {
            const localVarFetchArgs = DistrictApiFetchParamCreator(configuration).getTeamDistricts(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DistrictApi - factory interface
 * @export
 */
export const DistrictApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getDistrictEvents(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getDistrictRankings(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getDistrictTeams(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of districts and their corresponding district key, for the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictsByYear(year: number, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getDistrictsByYear(year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDistrictPoints(eventKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getEventDistrictPoints(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets an array of districts representing each year the team was in a district. Will return an empty array if the team was never in a district.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDistricts(teamKey: string, ifNoneMatch?: string, options?: any) {
            return DistrictApiFp(configuration).getTeamDistricts(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * DistrictApi - object-oriented interface
 * @export
 * @class DistrictApi
 * @extends {BaseAPI}
 */
export class DistrictApi extends BaseAPI {
    /**
     * Gets a list of events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getDistrictEvents(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of event keys for events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of team district rankings for the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getDistrictRankings(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getDistrictTeams(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of districts and their corresponding district key, for the given year.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getDistrictsByYear(year: number, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getDistrictsByYear(year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of team rankings for the Event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getEventDistrictPoints(eventKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getEventDistrictPoints(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets an array of districts representing each year the team was in a district. Will return an empty array if the team was never in a district.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistrictApi
     */
    public getTeamDistricts(teamKey: string, ifNoneMatch?: string, options?: any) {
        return DistrictApiFp(this.configuration).getTeamDistricts(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}
/**
 * EventApi - fetch parameter creator
 * @export
 */
export const EventApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEvents.');
            }
            const localVarPath = `/district/{district_key}/events`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEventsKeys.');
            }
            const localVarPath = `/district/{district_key}/events/keys`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEventsSimple.');
            }
            const localVarPath = `/district/{district_key}/events/simple`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEvent.');
            }
            const localVarPath = `/event/{event_key}`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of Elimination Alliances for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAlliances(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventAlliances.');
            }
            const localVarPath = `/event/{event_key}/alliances`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of awards from the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAwards(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventAwards.');
            }
            const localVarPath = `/event/{event_key}/awards`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDistrictPoints(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventDistrictPoints.');
            }
            const localVarPath = `/event/{event_key}/district_points`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a set of Event-specific insights for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInsights(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventInsights.');
            }
            const localVarPath = `/event/{event_key}/insights`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of Match Keys for the given event key that have timeseries data. Returns an empty array if no matches have timeseries data. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchTimeseries(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventMatchTimeseries.');
            }
            const localVarPath = `/event/{event_key}/matches/timeseries`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatches(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventMatches.');
            }
            const localVarPath = `/event/{event_key}/matches`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of match keys for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesKeys(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventMatchesKeys.');
            }
            const localVarPath = `/event/{event_key}/matches/keys`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesSimple(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventMatchesSimple.');
            }
            const localVarPath = `/event/{event_key}/matches/simple`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a set of Event OPRs (including OPR, DPR, and CCWM) for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventOPRs(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventOPRs.');
            }
            const localVarPath = `/event/{event_key}/oprs`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information on TBA-generated predictions for the given Event. Contains year-specific information. *WARNING* This endpoint is currently under development and may change at any time.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventPredictions(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventPredictions.');
            }
            const localVarPath = `/event/{event_key}/predictions`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRankings(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventRankings.');
            }
            const localVarPath = `/event/{event_key}/rankings`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSimple(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventSimple.');
            }
            const localVarPath = `/event/{event_key}/simple`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeams.');
            }
            const localVarPath = `/event/{event_key}/teams`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsKeys.');
            }
            const localVarPath = `/event/{event_key}/teams/keys`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsSimple.');
            }
            const localVarPath = `/event/{event_key}/teams/simple`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsStatuses.');
            }
            const localVarPath = `/event/{event_key}/teams/statuses`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYear(year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getEventsByYear.');
            }
            const localVarPath = `/events/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of event keys in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearKeys(year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getEventsByYearKeys.');
            }
            const localVarPath = `/events/{year}/keys`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearSimple(year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getEventsByYearSimple.');
            }
            const localVarPath = `/events/{year}/simple`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of awards the given team won at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventAwards(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventAwards.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventAwards.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/awards`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatches.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatches.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatchesKeys.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatchesKeys.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatchesSimple.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatchesSimple.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the competition rank and status of the team at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventStatus(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventStatus.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventStatus.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/status`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEvents(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEvents.');
            }
            const localVarPath = `/team/{team_key}/events`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsByYear.');
            }
            const localVarPath = `/team/{team_key}/events/{year}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of the event keys for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsByYearKeys.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsByYearKeys.');
            }
            const localVarPath = `/team/{team_key}/events/{year}/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsByYearSimple.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsByYearSimple.');
            }
            const localVarPath = `/team/{team_key}/events/{year}/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of the event keys for all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsKeys(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsKeys.');
            }
            const localVarPath = `/team/{team_key}/events/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsSimple(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsSimple.');
            }
            const localVarPath = `/team/{team_key}/events/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsStatusesByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsStatusesByYear.');
            }
            const localVarPath = `/team/{team_key}/events/{year}/statuses`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getDistrictEvents(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets an Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEvent(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of Elimination Alliances for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAlliances(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EliminationAlliance>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventAlliances(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of awards from the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAwards(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Award>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventAwards(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDistrictPoints(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventDistrictPoints> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventDistrictPoints(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a set of Event-specific insights for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInsights(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventInsights> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventInsights(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets an array of Match Keys for the given event key that have timeseries data. Returns an empty array if no matches have timeseries data. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchTimeseries(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventMatchTimeseries(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatches(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventMatches(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of match keys for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesKeys(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventMatchesKeys(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesSimple(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MatchSimple>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventMatchesSimple(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a set of Event OPRs (including OPR, DPR, and CCWM) for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventOPRs(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventOPRs> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventOPRs(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets information on TBA-generated predictions for the given Event. Contains year-specific information. *WARNING* This endpoint is currently under development and may change at any time.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventPredictions(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventPredictions> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventPredictions(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRankings(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventRanking> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventRankings(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSimple(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventSimple> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventSimple(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventTeams(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: TeamEventStatus; }> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYear(year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventsByYear(year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of event keys in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearKeys(year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventsByYearKeys(year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearSimple(year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventsByYearSimple(year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of awards the given team won at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventAwards(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Award>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventAwards(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the competition rank and status of the team at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventStatus(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamEventStatus> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventStatus(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEvents(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEvents(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventsByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of the event keys for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventsByYearKeys(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventsByYearSimple(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of the event keys for all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsKeys(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventsKeys(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsSimple(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventsSimple(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: TeamEventStatus; }> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getDistrictEvents(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets an Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEvent(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of Elimination Alliances for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAlliances(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventAlliances(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of awards from the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAwards(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventAwards(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDistrictPoints(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventDistrictPoints(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a set of Event-specific insights for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInsights(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventInsights(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets an array of Match Keys for the given event key that have timeseries data. Returns an empty array if no matches have timeseries data. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchTimeseries(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventMatchTimeseries(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatches(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventMatches(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of match keys for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventMatchesKeys(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventMatchesSimple(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a set of Event OPRs (including OPR, DPR, and CCWM) for the given Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventOPRs(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventOPRs(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets information on TBA-generated predictions for the given Event. Contains year-specific information. *WARNING* This endpoint is currently under development and may change at any time.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventPredictions(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventPredictions(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of team rankings for the Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventRankings(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventRankings(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form Event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventSimple(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventTeams(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYear(year: number, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventsByYear(year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of event keys in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearKeys(year: number, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventsByYearKeys(year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearSimple(year: number, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getEventsByYearSimple(year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of awards the given team won at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventAwards(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventAwards(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets the competition rank and status of the team at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventStatus(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventStatus(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEvents(teamKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEvents(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventsByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of the event keys for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventsByYearKeys(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventsByYearSimple(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of the event keys for all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsKeys(teamKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventsKeys(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsSimple(teamKey: string, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventsSimple(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return EventApiFp(configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * Gets a list of events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getDistrictEvents(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of event keys for events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets an Event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEvent(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEvent(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of Elimination Alliances for the given Event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventAlliances(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventAlliances(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of awards from the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventAwards(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventAwards(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of team rankings for the Event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventDistrictPoints(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventDistrictPoints(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a set of Event-specific insights for the given Event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventInsights(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventInsights(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets an array of Match Keys for the given event key that have timeseries data. Returns an empty array if no matches have timeseries data. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventMatchTimeseries(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventMatchTimeseries(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of matches for the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventMatches(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventMatches(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of match keys for the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventMatchesKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventMatchesKeys(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of matches for the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventMatchesSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventMatchesSimple(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a set of Event OPRs (including OPR, DPR, and CCWM) for the given Event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventOPRs(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventOPRs(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets information on TBA-generated predictions for the given Event. Contains year-specific information. *WARNING* This endpoint is currently under development and may change at any time.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventPredictions(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventPredictions(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of team rankings for the Event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventRankings(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventRankings(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form Event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventSimple(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventTeams(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` keys that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of `Team` objects that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a key-value list of the event statuses for teams competing at the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of events in the given year.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventsByYear(year: number, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventsByYear(year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of event keys in the given year.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventsByYearKeys(year: number, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventsByYearKeys(year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of events in the given year.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventsByYearSimple(year: number, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getEventsByYearSimple(year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of awards the given team won at the given event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventAwards(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventAwards(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of match keys for matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the competition rank and status of the team at the given event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventStatus(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventStatus(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of all events this team has competed at.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEvents(teamKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEvents(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventsByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of the event keys for events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventsByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventsByYearKeys(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventsByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventsByYearSimple(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of the event keys for all events this team has competed at.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventsKeys(teamKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventsKeys(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of all events this team has competed at.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventsSimple(teamKey: string, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventsSimple(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a key-value list of the event statuses for events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return EventApiFp(this.configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}
/**
 * ListApi - fetch parameter creator
 * @export
 */
export const ListApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEvents.');
            }
            const localVarPath = `/district/{district_key}/events`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEventsKeys.');
            }
            const localVarPath = `/district/{district_key}/events/keys`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictEventsSimple.');
            }
            const localVarPath = `/district/{district_key}/events/simple`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictRankings.');
            }
            const localVarPath = `/district/{district_key}/rankings`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeams.');
            }
            const localVarPath = `/district/{district_key}/teams`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeamsKeys.');
            }
            const localVarPath = `/district/{district_key}/teams/keys`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeamsSimple.');
            }
            const localVarPath = `/district/{district_key}/teams/simple`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeams.');
            }
            const localVarPath = `/event/{event_key}/teams`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsKeys.');
            }
            const localVarPath = `/event/{event_key}/teams/keys`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsSimple.');
            }
            const localVarPath = `/event/{event_key}/teams/simple`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsStatuses.');
            }
            const localVarPath = `/event/{event_key}/teams/statuses`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYear(year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getEventsByYear.');
            }
            const localVarPath = `/events/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of event keys in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearKeys(year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getEventsByYearKeys.');
            }
            const localVarPath = `/events/{year}/keys`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearSimple(year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getEventsByYearSimple.');
            }
            const localVarPath = `/events/{year}/simple`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsStatusesByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsStatusesByYear.');
            }
            const localVarPath = `/team/{team_key}/events/{year}/statuses`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeams.');
            }
            const localVarPath = `/teams/{page_num}`
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYear(year: number, pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamsByYear.');
            }
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsByYear.');
            }
            const localVarPath = `/teams/{year}/{page_num}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list Team Keys that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearKeys(year: number, pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamsByYearKeys.');
            }
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsByYearKeys.');
            }
            const localVarPath = `/teams/{year}/{page_num}/keys`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearSimple(year: number, pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamsByYearSimple.');
            }
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsByYearSimple.');
            }
            const localVarPath = `/teams/{year}/{page_num}/simple`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsKeys(pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsKeys.');
            }
            const localVarPath = `/teams/{page_num}/keys`
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsSimple(pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsSimple.');
            }
            const localVarPath = `/teams/{page_num}/simple`
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListApi - functional programming interface
 * @export
 */
export const ListApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getDistrictEvents(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DistrictRanking>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getDistrictRankings(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getDistrictTeams(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getEventTeams(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: TeamEventStatus; }> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYear(year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getEventsByYear(year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of event keys in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearKeys(year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getEventsByYearKeys(year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearSimple(year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getEventsByYearSimple(year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: TeamEventStatus; }> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getTeams(pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYear(year: number, pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getTeamsByYear(year, pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list Team Keys that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearKeys(year: number, pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getTeamsByYearKeys(year, pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearSimple(year: number, pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getTeamsByYearSimple(year, pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsKeys(pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getTeamsKeys(pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsSimple(pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).getTeamsSimple(pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ListApi - factory interface
 * @export
 */
export const ListApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Gets a list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getDistrictEvents(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of event keys for events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getDistrictRankings(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getDistrictTeams(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getEventTeams(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYear(year: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getEventsByYear(year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of event keys in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearKeys(year: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getEventsByYearKeys(year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of events in the given year.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByYearSimple(year: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getEventsByYearSimple(year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(pageNum: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getTeams(pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYear(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getTeamsByYear(year, pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list Team Keys that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearKeys(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getTeamsByYearKeys(year, pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearSimple(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getTeamsByYearSimple(year, pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsKeys(pageNum: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getTeamsKeys(pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsSimple(pageNum: number, ifNoneMatch?: string, options?: any) {
            return ListApiFp(configuration).getTeamsSimple(pageNum, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * ListApi - object-oriented interface
 * @export
 * @class ListApi
 * @extends {BaseAPI}
 */
export class ListApi extends BaseAPI {
    /**
     * Gets a list of events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getDistrictEvents(districtKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getDistrictEvents(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of event keys for events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getDistrictEventsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getDistrictEventsKeys(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getDistrictEventsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getDistrictEventsSimple(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of team district rankings for the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getDistrictRankings(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getDistrictTeams(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getEventTeams(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` keys that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of `Team` objects that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a key-value list of the event statuses for teams competing at the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of events in the given year.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getEventsByYear(year: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getEventsByYear(year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of event keys in the given year.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getEventsByYearKeys(year: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getEventsByYearKeys(year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of events in the given year.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getEventsByYearSimple(year: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getEventsByYearSimple(year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a key-value list of the event statuses for events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects, paginated in groups of 500.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getTeams(pageNum: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getTeams(pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getTeamsByYear(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getTeamsByYear(year, pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list Team Keys that competed in the given year, paginated in groups of 500.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getTeamsByYearKeys(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getTeamsByYearKeys(year, pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getTeamsByYearSimple(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getTeamsByYearSimple(year, pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getTeamsKeys(pageNum: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getTeamsKeys(pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public getTeamsSimple(pageNum: number, ifNoneMatch?: string, options?: any) {
        return ListApiFp(this.configuration).getTeamsSimple(pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}
/**
 * MatchApi - fetch parameter creator
 * @export
 */
export const MatchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets an array of Match Keys for the given event key that have timeseries data. Returns an empty array if no matches have timeseries data. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchTimeseries(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventMatchTimeseries.');
            }
            const localVarPath = `/event/{event_key}/matches/timeseries`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatches(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventMatches.');
            }
            const localVarPath = `/event/{event_key}/matches`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of match keys for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesKeys(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventMatchesKeys.');
            }
            const localVarPath = `/event/{event_key}/matches/keys`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesSimple(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventMatchesSimple.');
            }
            const localVarPath = `/event/{event_key}/matches/simple`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a `Match` object for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch(matchKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'matchKey' is not null or undefined
            if (matchKey === null || matchKey === undefined) {
                throw new RequiredError('matchKey','Required parameter matchKey was null or undefined when calling getMatch.');
            }
            const localVarPath = `/match/{match_key}`
                .replace(`{${"match_key"}}`, encodeURIComponent(String(matchKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form `Match` object for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchSimple(matchKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'matchKey' is not null or undefined
            if (matchKey === null || matchKey === undefined) {
                throw new RequiredError('matchKey','Required parameter matchKey was null or undefined when calling getMatchSimple.');
            }
            const localVarPath = `/match/{match_key}/simple`
                .replace(`{${"match_key"}}`, encodeURIComponent(String(matchKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of game-specific Match Timeseries objects for the given match key or an empty array if not available. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchTimeseries(matchKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'matchKey' is not null or undefined
            if (matchKey === null || matchKey === undefined) {
                throw new RequiredError('matchKey','Required parameter matchKey was null or undefined when calling getMatchTimeseries.');
            }
            const localVarPath = `/match/{match_key}/timeseries`
                .replace(`{${"match_key"}}`, encodeURIComponent(String(matchKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets Zebra MotionWorks data for a Match for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchZebra(matchKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'matchKey' is not null or undefined
            if (matchKey === null || matchKey === undefined) {
                throw new RequiredError('matchKey','Required parameter matchKey was null or undefined when calling getMatchZebra.');
            }
            const localVarPath = `/match/{match_key}/zebra_motionworks`
                .replace(`{${"match_key"}}`, encodeURIComponent(String(matchKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatches.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatches.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatchesKeys.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatchesKeys.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatchesSimple.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatchesSimple.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMatchesByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamMatchesByYear.');
            }
            const localVarPath = `/team/{team_key}/matches/{year}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMatchesByYearKeys.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamMatchesByYearKeys.');
            }
            const localVarPath = `/team/{team_key}/matches/{year}/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMatchesByYearSimple.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamMatchesByYearSimple.');
            }
            const localVarPath = `/team/{team_key}/matches/{year}/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchApi - functional programming interface
 * @export
 */
export const MatchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets an array of Match Keys for the given event key that have timeseries data. Returns an empty array if no matches have timeseries data. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchTimeseries(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getEventMatchTimeseries(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatches(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getEventMatches(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of match keys for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesKeys(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getEventMatchesKeys(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesSimple(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MatchSimple>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getEventMatchesSimple(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a `Match` object for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch(matchKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Match> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getMatch(matchKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form `Match` object for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchSimple(matchKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MatchSimple> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getMatchSimple(matchKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets an array of game-specific Match Timeseries objects for the given match key or an empty array if not available. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchTimeseries(matchKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getMatchTimeseries(matchKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets Zebra MotionWorks data for a Match for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchZebra(matchKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Zebra> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getMatchZebra(matchKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getTeamMatchesByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getTeamMatchesByYearKeys(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MatchSimple>> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getTeamMatchesByYearSimple(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MatchApi - factory interface
 * @export
 */
export const MatchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Gets an array of Match Keys for the given event key that have timeseries data. Returns an empty array if no matches have timeseries data. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchTimeseries(eventKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getEventMatchTimeseries(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatches(eventKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getEventMatches(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of match keys for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getEventMatchesKeys(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of matches for the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMatchesSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getEventMatchesSimple(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a `Match` object for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch(matchKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getMatch(matchKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form `Match` object for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchSimple(matchKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getMatchSimple(matchKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets an array of game-specific Match Timeseries objects for the given match key or an empty array if not available. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchTimeseries(matchKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getMatchTimeseries(matchKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets Zebra MotionWorks data for a Match for the given match key.
         * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchZebra(matchKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getMatchZebra(matchKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getTeamMatchesByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of match keys for matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getTeamMatchesByYearKeys(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return MatchApiFp(configuration).getTeamMatchesByYearSimple(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * MatchApi - object-oriented interface
 * @export
 * @class MatchApi
 * @extends {BaseAPI}
 */
export class MatchApi extends BaseAPI {
    /**
     * Gets an array of Match Keys for the given event key that have timeseries data. Returns an empty array if no matches have timeseries data. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getEventMatchTimeseries(eventKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getEventMatchTimeseries(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of matches for the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getEventMatches(eventKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getEventMatches(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of match keys for the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getEventMatchesKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getEventMatchesKeys(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of matches for the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getEventMatchesSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getEventMatchesSimple(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a `Match` object for the given match key.
     * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getMatch(matchKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getMatch(matchKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form `Match` object for the given match key.
     * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getMatchSimple(matchKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getMatchSimple(matchKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets an array of game-specific Match Timeseries objects for the given match key or an empty array if not available. *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up. *WARNING:* This endpoint and corresponding data models are under *active development* and may change at any time, including in breaking ways.
     * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getMatchTimeseries(matchKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getMatchTimeseries(matchKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets Zebra MotionWorks data for a Match for the given match key.
     * @param {string} matchKey TBA Match Key, eg &#x60;2016nytr_qm1&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getMatchZebra(matchKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getMatchZebra(matchKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of match keys for matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of matches for the given team and year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getTeamMatchesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getTeamMatchesByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of match keys for matches for the given team and year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getTeamMatchesByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getTeamMatchesByYearKeys(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of matches for the given team and year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getTeamMatchesByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return MatchApiFp(this.configuration).getTeamMatchesByYearSimple(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}
/**
 * TBAApi - fetch parameter creator
 * @export
 */
export const TBAApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns API status, and TBA status information.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TBAApi - functional programming interface
 * @export
 */
export const TBAApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns API status, and TBA status information.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<APIStatus> {
            const localVarFetchArgs = TBAApiFetchParamCreator(configuration).getStatus(ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TBAApi - factory interface
 * @export
 */
export const TBAApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns API status, and TBA status information.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(ifNoneMatch?: string, options?: any) {
            return TBAApiFp(configuration).getStatus(ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * TBAApi - object-oriented interface
 * @export
 * @class TBAApi
 * @extends {BaseAPI}
 */
export class TBAApi extends BaseAPI {
    /**
     * Returns API status, and TBA status information.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TBAApi
     */
    public getStatus(ifNoneMatch?: string, options?: any) {
        return TBAApiFp(this.configuration).getStatus(ifNoneMatch, options)(this.fetch, this.basePath);
    }

}
/**
 * TeamApi - fetch parameter creator
 * @export
 */
export const TeamApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictRankings.');
            }
            const localVarPath = `/district/{district_key}/rankings`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeams.');
            }
            const localVarPath = `/district/{district_key}/teams`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeamsKeys.');
            }
            const localVarPath = `/district/{district_key}/teams/keys`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'districtKey' is not null or undefined
            if (districtKey === null || districtKey === undefined) {
                throw new RequiredError('districtKey','Required parameter districtKey was null or undefined when calling getDistrictTeamsSimple.');
            }
            const localVarPath = `/district/{district_key}/teams/simple`
                .replace(`{${"district_key"}}`, encodeURIComponent(String(districtKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeams.');
            }
            const localVarPath = `/event/{event_key}/teams`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsKeys.');
            }
            const localVarPath = `/event/{event_key}/teams/keys`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsSimple.');
            }
            const localVarPath = `/event/{event_key}/teams/simple`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getEventTeamsStatuses.');
            }
            const localVarPath = `/event/{event_key}/teams/statuses`
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a `Team` object for the team referenced by the given key.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeam.');
            }
            const localVarPath = `/team/{team_key}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of awards the given team has won.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAwards(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamAwards.');
            }
            const localVarPath = `/team/{team_key}/awards`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of awards the given team has won in a given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAwardsByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamAwardsByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamAwardsByYear.');
            }
            const localVarPath = `/team/{team_key}/awards/{year}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of districts representing each year the team was in a district. Will return an empty array if the team was never in a district.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDistricts(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamDistricts.');
            }
            const localVarPath = `/team/{team_key}/districts`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of awards the given team won at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventAwards(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventAwards.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventAwards.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/awards`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatches.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatches.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatchesKeys.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatchesKeys.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventMatchesSimple.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventMatchesSimple.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/matches/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the competition rank and status of the team at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventStatus(teamKey: string, eventKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventStatus.');
            }
            // verify required parameter 'eventKey' is not null or undefined
            if (eventKey === null || eventKey === undefined) {
                throw new RequiredError('eventKey','Required parameter eventKey was null or undefined when calling getTeamEventStatus.');
            }
            const localVarPath = `/team/{team_key}/event/{event_key}/status`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"event_key"}}`, encodeURIComponent(String(eventKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEvents(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEvents.');
            }
            const localVarPath = `/team/{team_key}/events`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsByYear.');
            }
            const localVarPath = `/team/{team_key}/events/{year}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of the event keys for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsByYearKeys.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsByYearKeys.');
            }
            const localVarPath = `/team/{team_key}/events/{year}/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsByYearSimple.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsByYearSimple.');
            }
            const localVarPath = `/team/{team_key}/events/{year}/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of the event keys for all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsKeys(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsKeys.');
            }
            const localVarPath = `/team/{team_key}/events/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsSimple(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsSimple.');
            }
            const localVarPath = `/team/{team_key}/events/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamEventsStatusesByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamEventsStatusesByYear.');
            }
            const localVarPath = `/team/{team_key}/events/{year}/statuses`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMatchesByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamMatchesByYear.');
            }
            const localVarPath = `/team/{team_key}/matches/{year}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMatchesByYearKeys.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamMatchesByYearKeys.');
            }
            const localVarPath = `/team/{team_key}/matches/{year}/keys`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a short-form list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMatchesByYearSimple.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamMatchesByYearSimple.');
            }
            const localVarPath = `/team/{team_key}/matches/{year}/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team and tag.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} mediaTag Media Tag which describes the Media.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByTag(teamKey: string, mediaTag: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMediaByTag.');
            }
            // verify required parameter 'mediaTag' is not null or undefined
            if (mediaTag === null || mediaTag === undefined) {
                throw new RequiredError('mediaTag','Required parameter mediaTag was null or undefined when calling getTeamMediaByTag.');
            }
            const localVarPath = `/team/{team_key}/media/tag/{media_tag}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"media_tag"}}`, encodeURIComponent(String(mediaTag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team, tag and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} mediaTag Media Tag which describes the Media.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByTagYear(teamKey: string, mediaTag: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMediaByTagYear.');
            }
            // verify required parameter 'mediaTag' is not null or undefined
            if (mediaTag === null || mediaTag === undefined) {
                throw new RequiredError('mediaTag','Required parameter mediaTag was null or undefined when calling getTeamMediaByTagYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamMediaByTagYear.');
            }
            const localVarPath = `/team/{team_key}/media/tag/{media_tag}/{year}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"media_tag"}}`, encodeURIComponent(String(mediaTag)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByYear(teamKey: string, year: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamMediaByYear.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamMediaByYear.');
            }
            const localVarPath = `/team/{team_key}/media/{year}`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)))
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of year and robot name pairs for each year that a robot name was provided. Will return an empty array if the team has never named a robot.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamRobots(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamRobots.');
            }
            const localVarPath = `/team/{team_key}/robots`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a `Team_Simple` object for the team referenced by the given key.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSimple(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamSimple.');
            }
            const localVarPath = `/team/{team_key}/simple`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of Media (social media) for the given team.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSocialMedia(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamSocialMedia.');
            }
            const localVarPath = `/team/{team_key}/social_media`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of years in which the team participated in at least one competition.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamYearsParticipated(teamKey: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamKey' is not null or undefined
            if (teamKey === null || teamKey === undefined) {
                throw new RequiredError('teamKey','Required parameter teamKey was null or undefined when calling getTeamYearsParticipated.');
            }
            const localVarPath = `/team/{team_key}/years_participated`
                .replace(`{${"team_key"}}`, encodeURIComponent(String(teamKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeams.');
            }
            const localVarPath = `/teams/{page_num}`
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYear(year: number, pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamsByYear.');
            }
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsByYear.');
            }
            const localVarPath = `/teams/{year}/{page_num}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list Team Keys that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearKeys(year: number, pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamsByYearKeys.');
            }
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsByYearKeys.');
            }
            const localVarPath = `/teams/{year}/{page_num}/keys`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearSimple(year: number, pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getTeamsByYearSimple.');
            }
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsByYearSimple.');
            }
            const localVarPath = `/teams/{year}/{page_num}/simple`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsKeys(pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsKeys.');
            }
            const localVarPath = `/teams/{page_num}/keys`
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsSimple(pageNum: number, ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'pageNum' is not null or undefined
            if (pageNum === null || pageNum === undefined) {
                throw new RequiredError('pageNum','Required parameter pageNum was null or undefined when calling getTeamsSimple.');
            }
            const localVarPath = `/teams/{page_num}/simple`
                .replace(`{${"page_num"}}`, encodeURIComponent(String(pageNum)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TBA-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-TBA-Auth-Key"] = localVarApiKeyValue;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DistrictRanking>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getDistrictRankings(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getDistrictTeams(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getEventTeams(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: TeamEventStatus; }> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a `Team` object for the team referenced by the given key.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeam(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of awards the given team has won.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAwards(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Award>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamAwards(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of awards the given team has won in a given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAwardsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Award>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamAwardsByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets an array of districts representing each year the team was in a district. Will return an empty array if the team was never in a district.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDistricts(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DistrictList>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamDistricts(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of awards the given team won at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventAwards(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Award>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventAwards(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the competition rank and status of the team at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventStatus(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamEventStatus> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventStatus(teamKey, eventKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEvents(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEvents(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventsByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of the event keys for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventsByYearKeys(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventsByYearSimple(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of the event keys for all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsKeys(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventsKeys(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsSimple(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSimple>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventsSimple(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: TeamEventStatus; }> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamMatchesByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of match keys for matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamMatchesByYearKeys(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a short-form list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MatchSimple>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamMatchesByYearSimple(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team and tag.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} mediaTag Media Tag which describes the Media.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByTag(teamKey: string, mediaTag: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Media>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamMediaByTag(teamKey, mediaTag, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team, tag and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} mediaTag Media Tag which describes the Media.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByTagYear(teamKey: string, mediaTag: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Media>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamMediaByTagYear(teamKey, mediaTag, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Media>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamMediaByYear(teamKey, year, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of year and robot name pairs for each year that a robot name was provided. Will return an empty array if the team has never named a robot.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamRobots(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamRobot>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamRobots(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a `Team_Simple` object for the team referenced by the given key.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSimple(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamSimple> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamSimple(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of Media (social media) for the given team.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSocialMedia(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Media>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamSocialMedia(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of years in which the team participated in at least one competition.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamYearsParticipated(teamKey: string, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamYearsParticipated(teamKey, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeams(pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYear(year: number, pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamsByYear(year, pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list Team Keys that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearKeys(year: number, pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamsByYearKeys(year, pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearSimple(year: number, pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamsByYearSimple(year, pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsKeys(pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamsKeys(pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsSimple(pageNum: number, ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamSimple>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamsSimple(pageNum, ifNoneMatch, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Gets a list of team district rankings for the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getDistrictRankings(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getDistrictTeams(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of `Team` objects that competed in events in the given district.
         * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getEventTeams(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` keys that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of `Team` objects that competed in the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a key-value list of the event statuses for teams competing at the given event.
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a `Team` object for the team referenced by the given key.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeam(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of awards the given team has won.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAwards(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamAwards(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of awards the given team has won in a given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAwardsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamAwardsByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets an array of districts representing each year the team was in a district. Will return an empty array if the team was never in a district.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDistricts(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamDistricts(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of awards the given team won at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventAwards(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventAwards(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of match keys for matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of matches for the given team and event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets the competition rank and status of the team at the given event.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventStatus(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventStatus(teamKey, eventKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEvents(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEvents(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventsByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of the event keys for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventsByYearKeys(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventsByYearSimple(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of the event keys for all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsKeys(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventsKeys(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of all events this team has competed at.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsSimple(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventsSimple(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a key-value list of the event statuses for events this team has competed at in the given year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamMatchesByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of match keys for matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamMatchesByYearKeys(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a short-form list of matches for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMatchesByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamMatchesByYearSimple(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team and tag.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} mediaTag Media Tag which describes the Media.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByTag(teamKey: string, mediaTag: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamMediaByTag(teamKey, mediaTag, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team, tag and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} mediaTag Media Tag which describes the Media.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByTagYear(teamKey: string, mediaTag: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamMediaByTagYear(teamKey, mediaTag, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of Media (videos / pictures) for the given team and year.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMediaByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamMediaByYear(teamKey, year, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of year and robot name pairs for each year that a robot name was provided. Will return an empty array if the team has never named a robot.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamRobots(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamRobots(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a `Team_Simple` object for the team referenced by the given key.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSimple(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamSimple(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of Media (social media) for the given team.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSocialMedia(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamSocialMedia(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of years in which the team participated in at least one competition.
         * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamYearsParticipated(teamKey: string, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamYearsParticipated(teamKey, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(pageNum: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeams(pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYear(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamsByYear(year, pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list Team Keys that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearKeys(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamsByYearKeys(year, pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
         * @param {number} year Competition Year (or Season). Must be 4 digits.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByYearSimple(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamsByYearSimple(year, pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsKeys(pageNum: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamsKeys(pageNum, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
         * @param {number} pageNum Page number of results to return, zero-indexed
         * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsSimple(pageNum: number, ifNoneMatch?: string, options?: any) {
            return TeamApiFp(configuration).getTeamsSimple(pageNum, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * Gets a list of team district rankings for the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getDistrictRankings(districtKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getDistrictRankings(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getDistrictTeams(districtKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getDistrictTeams(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getDistrictTeamsKeys(districtKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getDistrictTeamsKeys(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of `Team` objects that competed in events in the given district.
     * @param {string} districtKey TBA District Key, eg &#x60;2016fim&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getDistrictTeamsSimple(districtKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getDistrictTeamsSimple(districtKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getEventTeams(eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getEventTeams(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` keys that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getEventTeamsKeys(eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getEventTeamsKeys(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of `Team` objects that competed in the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getEventTeamsSimple(eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getEventTeamsSimple(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a key-value list of the event statuses for teams competing at the given event.
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getEventTeamsStatuses(eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getEventTeamsStatuses(eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a `Team` object for the team referenced by the given key.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeam(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeam(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of awards the given team has won.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamAwards(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamAwards(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of awards the given team has won in a given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamAwardsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamAwardsByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets an array of districts representing each year the team was in a district. Will return an empty array if the team was never in a district.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamDistricts(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamDistricts(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of awards the given team won at the given event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventAwards(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventAwards(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventMatches(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventMatches(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of match keys for matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventMatchesKeys(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventMatchesKeys(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of matches for the given team and event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventMatchesSimple(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventMatchesSimple(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the competition rank and status of the team at the given event.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} eventKey TBA Event Key, eg &#x60;2016nytr&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventStatus(teamKey: string, eventKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventStatus(teamKey, eventKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of all events this team has competed at.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEvents(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEvents(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventsByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventsByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of the event keys for events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventsByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventsByYearKeys(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventsByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventsByYearSimple(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of the event keys for all events this team has competed at.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventsKeys(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventsKeys(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of all events this team has competed at.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventsSimple(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventsSimple(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a key-value list of the event statuses for events this team has competed at in the given year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamEventsStatusesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamEventsStatusesByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of matches for the given team and year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamMatchesByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamMatchesByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of match keys for matches for the given team and year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamMatchesByYearKeys(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamMatchesByYearKeys(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a short-form list of matches for the given team and year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamMatchesByYearSimple(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamMatchesByYearSimple(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of Media (videos / pictures) for the given team and tag.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} mediaTag Media Tag which describes the Media.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamMediaByTag(teamKey: string, mediaTag: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamMediaByTag(teamKey, mediaTag, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of Media (videos / pictures) for the given team, tag and year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} mediaTag Media Tag which describes the Media.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamMediaByTagYear(teamKey: string, mediaTag: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamMediaByTagYear(teamKey, mediaTag, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of Media (videos / pictures) for the given team and year.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamMediaByYear(teamKey: string, year: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamMediaByYear(teamKey, year, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of year and robot name pairs for each year that a robot name was provided. Will return an empty array if the team has never named a robot.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamRobots(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamRobots(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a `Team_Simple` object for the team referenced by the given key.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamSimple(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamSimple(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of Media (social media) for the given team.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamSocialMedia(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamSocialMedia(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of years in which the team participated in at least one competition.
     * @param {string} teamKey TBA Team Key, eg &#x60;frc254&#x60;
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamYearsParticipated(teamKey: string, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamYearsParticipated(teamKey, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects, paginated in groups of 500.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeams(pageNum: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeams(pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamsByYear(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamsByYear(year, pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list Team Keys that competed in the given year, paginated in groups of 500.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamsByYearKeys(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamsByYearKeys(year, pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
     * @param {number} year Competition Year (or Season). Must be 4 digits.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamsByYearSimple(year: number, pageNum: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamsByYearSimple(year, pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamsKeys(pageNum: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamsKeys(pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
     * @param {number} pageNum Page number of results to return, zero-indexed
     * @param {string} [ifNoneMatch] Value of the &#x60;ETag&#x60; header in the most recently cached response by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamsSimple(pageNum: number, ifNoneMatch?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamsSimple(pageNum, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}
